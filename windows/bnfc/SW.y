/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.3). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the sw_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE sw__scan_string(const char *str, yyscan_t scanner);
extern void sw__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void sw_lex_destroy(yyscan_t scanner);
extern char* sw_get_text(yyscan_t scanner);

extern yyscan_t sw__initialize_lexer(FILE * inp);

/* List reversal functions. */
ListStm reverseListStm(ListStm l)
{
  ListStm prev = 0;
  ListStm tmp = 0;
  while (l)
  {
    tmp = l->liststm_;
    l->liststm_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListSubnet reverseListSubnet(ListSubnet l)
{
  ListSubnet prev = 0;
  ListSubnet tmp = 0;
  while (l)
  {
    tmp = l->listsubnet_;
    l->listsubnet_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListArgument reverseListArgument(ListArgument l)
{
  ListArgument prev = 0;
  ListArgument tmp = 0;
  while (l)
  {
    tmp = l->listargument_;
    l->listargument_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListCentry reverseListCentry(ListCentry l)
{
  ListCentry prev = 0;
  ListCentry tmp = 0;
  while (l)
  {
    tmp = l->listcentry_;
    l->listcentry_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListEntry reverseListEntry(ListEntry l)
{
  ListEntry prev = 0;
  ListEntry tmp = 0;
  while (l)
  {
    tmp = l->listentry_;
    l->listentry_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Valide valide_;
  ValidSW validsw_;
  Stm stm_;
  ListStm liststm_;
  Subdef subdef_;
  Subnet subnet_;
  ListSubnet listsubnet_;
  ExtPortIn extportin_;
  ExtPortOut extportout_;
  Tab tab_;
  DataFlow dataflow_;
  Larrow larrow_;
  Rarrow rarrow_;
  TypeDef typedef_;
  Buffsize buffsize_;
  Hermt hermt_;
  Symvalu symvalu_;
  Proc proc_;
  Prt prt_;
  Comp comp_;
  ModPath modpath_;
  RemPath rempath_;
  Argument argument_;
  ListArgument listargument_;
  Numassgn numassgn_;
  Strassgn strassgn_;
  SymAssgn symassgn_;
  Numval numval_;
  Stringval stringval_;
  Symval symval_;
  Include include_;
  Prefix prefix_;
  ValidConfig validconfig_;
  Centry centry_;
  ListCentry listcentry_;
  Entry entry_;
  ListEntry listentry_;
  KeyVal keyval_;
  KeyName keyname_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, sw_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _LPAREN        /* ( */
%token          _RPAREN        /* ) */
%token          _COMMA         /* , */
%token          _MINUS         /* - */
%token          _SYMB_13       /* --- */
%token          _DOT           /* . */
%token          _SLASH         /* / */
%token          _COLON         /* : */
%token          _SEMI          /* ; */
%token          _LT            /* < */
%token          _EQ            /* = */
%token          _GT            /* > */
%token          _KW_INCLUDE    /* INCLUDE */
%token          _KW_PREFIX     /* PREFIX */
%token          _SYMB_12       /* StreamWork: */
%token          _UNDERSCORE    /* _ */
%token          _KW_include    /* include */
%token          _KW_prefix     /* prefix */
%token          _LBRACE        /* { */
%token          _RBRACE        /* } */
%token<_string> T_Date         /* Date */
%token<_string> T_Envar        /* Envar */
%token<_string> T_Id           /* Id */
%token<_string> T_Numvar       /* Numvar */
%token<_string> T_Stringvar    /* Stringvar */
%token<_string> T_SubId        /* SubId */
%token<_string> T_Symvar       /* Symvar */
%token<_string> T_ValidImport  /* ValidImport */
%token<_string> _STRING_
%token<_int>    _INTEGER_

%type <valide_> Valide
%type <validsw_> ValidSW
%type <stm_> Stm
%type <liststm_> ListStm
%type <subdef_> Subdef
%type <subnet_> Subnet
%type <listsubnet_> ListSubnet
%type <extportin_> ExtPortIn
%type <extportout_> ExtPortOut
%type <tab_> Tab
%type <dataflow_> DataFlow
%type <larrow_> Larrow
%type <rarrow_> Rarrow
%type <typedef_> TypeDef
%type <buffsize_> Buffsize
%type <hermt_> Hermt
%type <symvalu_> Symvalu
%type <proc_> Proc
%type <prt_> Prt
%type <comp_> Comp
%type <modpath_> ModPath
%type <rempath_> RemPath
%type <argument_> Argument
%type <listargument_> ListArgument
%type <numassgn_> Numassgn
%type <strassgn_> Strassgn
%type <symassgn_> SymAssgn
%type <numval_> Numval
%type <stringval_> Stringval
%type <symval_> Symval
%type <include_> Include
%type <prefix_> Prefix
%type <validconfig_> ValidConfig
%type <centry_> Centry
%type <listcentry_> ListCentry
%type <entry_> Entry
%type <listentry_> ListEntry
%type <keyval_> KeyVal
%type <keyname_> KeyName

%start Valide

%%

Valide : ValidConfig { $$ = make_CFGvalid($1); result->valide_ = $$; }
  | ValidSW { $$ = make_SWvalid($1); result->valide_ = $$; }
;
ValidSW : ListStm { $$ = make_Valid(reverseListStm($1)); result->validsw_ = $$; }
;
Stm : Prefix Stringval { $$ = make_StmPrefix($1, $2); }
  | Include Stringval { $$ = make_Stminc($1, $2); }
  | DataFlow { $$ = make_Stmx($1); }
  | Numassgn { $$ = make_Stmn($1); }
  | Strassgn { $$ = make_Stms($1); }
  | SymAssgn { $$ = make_Stmb($1); }
  | Hermt { $$ = make_Stmh($1); }
  | Subdef { $$ = make_Stmnet($1); }
;
ListStm : /* empty */ { $$ = 0; }
  | ListStm Stm _SEMI { $$ = make_ListStm($2, $1); }
;
Subdef : T_SubId _LBRACE ListSubnet _RBRACE { $$ = make_Snet($1, reverseListSubnet($3)); }
;
Subnet : Hermt { $$ = make_Sneth($1); }
  | DataFlow { $$ = make_Snets($1); }
  | ExtPortIn { $$ = make_Snetin($1); }
  | ExtPortOut { $$ = make_Snetout($1); }
;
ListSubnet : /* empty */ { $$ = 0; }
  | ListSubnet Subnet _SEMI { $$ = make_ListSubnet($2, $1); }
;
ExtPortIn : Proc Prt Larrow Tab { $$ = make_Extin($1, $2, $3, $4); }
  | Tab Rarrow Prt Proc { $$ = make_ExtinR($1, $2, $3, $4); }
;
ExtPortOut : Tab Larrow Prt Proc { $$ = make_Extout($1, $2, $3, $4); }
  | Proc Prt Rarrow Tab { $$ = make_Extoutr($1, $2, $3, $4); }
;
Tab : Numval { $$ = make_Tabn($1); }
  | Symval { $$ = make_Tabs($1); }
;
DataFlow : Proc Prt Larrow Prt Proc { $$ = make_Streamx($1, $2, $3, $4, $5); }
  | Proc Prt Rarrow Prt Proc { $$ = make_Streamrx($1, $2, $3, $4, $5); }
  | DataFlow Prt Larrow Prt Proc { $$ = make_Streamy($1, $2, $3, $4, $5); }
  | DataFlow Prt Rarrow Prt Proc { $$ = make_Streamry($1, $2, $3, $4, $5); }
;
Larrow : _LT TypeDef Buffsize _MINUS { $$ = make_Arrowx($2, $3); }
;
Rarrow : _MINUS TypeDef Buffsize _GT { $$ = make_Arrowr($2, $3); }
;
TypeDef : Symvalu { $$ = make_Typedefa($1); }
  | /* empty */ { $$ = make_Typedefnull(); }
;
Buffsize : Numval { $$ = make_Bufszi($1); }
  | /* empty */ { $$ = make_Bufsze(); }
;
Hermt : Symvalu Comp ListArgument { $$ = make_Hermtx($1, $2, reverseListArgument($3)); }
  | Symvalu ListArgument { $$ = make_Hermty($1, reverseListArgument($2)); }
;
Symvalu : Symval { $$ = make_Symvaluv($1); }
  | _UNDERSCORE { $$ = make_Symvaluu(); }
;
Proc : _LPAREN Symvalu Comp ListArgument _RPAREN { $$ = make_Processx($2, $3, reverseListArgument($4)); }
  | _LPAREN Symvalu ListArgument _RPAREN { $$ = make_Processy($2, reverseListArgument($3)); }
;
Prt : Numval { $$ = make_Portx($1); }
  | Numval _DOT Symval { $$ = make_Portni($1, $3); }
  | Symval _DOT Numval { $$ = make_Portin($1, $3); }
  | Symval { $$ = make_Portn($1); }
  | /* empty */ { $$ = make_Porte(); }
;
Comp : Symval { $$ = make_Compx($1); }
  | T_SubId { $$ = make_Compn($1); }
  | ModPath Symval { $$ = make_Compz($1, $2); }
  | RemPath { $$ = make_Compa($1); }
;
ModPath : _SLASH Symval _SLASH { $$ = make_Modpa($2); }
  | Symval _SLASH { $$ = make_Modpx($1); }
  | ModPath Symval _SLASH { $$ = make_Modpy($1, $2); }
  | T_Stringvar _SLASH { $$ = make_Modps($1); }
;
RemPath : T_ValidImport _DOT Symval { $$ = make_RemPatha($1, $3); }
;
Argument : Stringval { $$ = make_Argumentx($1); }
;
ListArgument : /* empty */ { $$ = 0; }
  | ListArgument Argument { $$ = make_ListArgument($2, $1); }
;
Numassgn : T_Numvar _EQ Numval { $$ = make_NumAssgnv($1, $3); }
;
Strassgn : T_Stringvar _EQ Stringval { $$ = make_StrAssgnv($1, $3); }
;
SymAssgn : T_Symvar _EQ Symval { $$ = make_SymAssgni($1, $3); }
;
Numval : _INTEGER_ { $$ = make_NumVali($1); }
  | T_Numvar { $$ = make_NumValv($1); }
;
Stringval : _STRING_ { $$ = make_StringVals($1); }
  | T_Stringvar { $$ = make_StringValv($1); }
  | T_Envar { $$ = make_StringVale($1); }
;
Symval : T_Symvar { $$ = make_Symvalv($1); }
  | T_Id { $$ = make_Symvali($1); }
  | T_Envar { $$ = make_SymVale($1); }
;
Include : _KW_include { $$ = make_Inc1(); }
  | _KW_INCLUDE { $$ = make_Inc2(); }
;
Prefix : _KW_PREFIX { $$ = make_Prefu(); }
  | _KW_prefix { $$ = make_Prefl(); }
;
ValidConfig : _SYMB_12 ListEntry { $$ = make_Validcfg(reverseListEntry($2)); result->validconfig_ = $$; }
  | _SYMB_13 _SYMB_12 _LBRACE ListCentry _RBRACE { $$ = make_Validcfgd(reverseListCentry($4)); result->validconfig_ = $$; }
;
Centry : KeyVal { $$ = make_CfgcEntrya($1); }
  | KeyName { $$ = make_CfgcEntryb($1); }
;
ListCentry : /* empty */ { $$ = 0; }
  | ListCentry Centry _COMMA { $$ = make_ListCentry($2, $1); }
;
Entry : KeyVal { $$ = make_CfgEntrya($1); }
  | KeyName { $$ = make_CfgEntryb($1); }
;
ListEntry : /* empty */ { $$ = 0; }
  | ListEntry Entry { $$ = make_ListEntry($2, $1); }
;
KeyVal : KeyName _INTEGER_ { $$ = make_CfgKeyvalint($1, $2); }
  | KeyName _STRING_ { $$ = make_CfgKeyvalstr($1, $2); }
  | KeyName T_Date { $$ = make_CfgKeyDate($1, $2); }
;
KeyName : Symval _COLON { $$ = make_KeynameS($1); }
  | ModPath Symval _COLON { $$ = make_KeynameM($1, $2); }
;

%%


/* Entrypoint: parse Valide from file. */
Valide pValide(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = sw__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  sw_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.valide_;
  }
}

/* Entrypoint: parse Valide from string. */
Valide psValide(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = sw__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = sw__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  sw__delete_buffer(buf, scanner);
  sw_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.valide_;
  }
}

/* Entrypoint: parse ValidSW from file. */
ValidSW pValidSW(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = sw__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  sw_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.validsw_;
  }
}

/* Entrypoint: parse ValidSW from string. */
ValidSW psValidSW(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = sw__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = sw__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  sw__delete_buffer(buf, scanner);
  sw_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.validsw_;
  }
}

/* Entrypoint: parse ValidConfig from file. */
ValidConfig pValidConfig(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = sw__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  sw_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.validconfig_;
  }
}

/* Entrypoint: parse ValidConfig from string. */
ValidConfig psValidConfig(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = sw__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = sw__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  sw__delete_buffer(buf, scanner);
  sw_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.validconfig_;
  }
}



