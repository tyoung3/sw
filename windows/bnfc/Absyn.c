/* File generated by the BNF Converter (bnfc 2.9.3). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   CFGvalid    ********************/

Valide make_CFGvalid(ValidConfig p1)
{
    Valide tmp = (Valide) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CFGvalid!\n");
        exit(1);
    }
    tmp->kind = is_CFGvalid;
    tmp->u.cfgvalid_.validconfig_ = p1;
    return tmp;
}

/********************   SWvalid    ********************/

Valide make_SWvalid(ValidSW p1)
{
    Valide tmp = (Valide) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SWvalid!\n");
        exit(1);
    }
    tmp->kind = is_SWvalid;
    tmp->u.swvalid_.validsw_ = p1;
    return tmp;
}

/********************   Valid    ********************/

ValidSW make_Valid(ListStm p1)
{
    ValidSW tmp = (ValidSW) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Valid!\n");
        exit(1);
    }
    tmp->kind = is_Valid;
    tmp->u.valid_.liststm_ = p1;
    return tmp;
}

/********************   StmPrefix    ********************/

Stm make_StmPrefix(Prefix p1, Stringval p2)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating StmPrefix!\n");
        exit(1);
    }
    tmp->kind = is_StmPrefix;
    tmp->u.stmprefix_.prefix_ = p1;
    tmp->u.stmprefix_.stringval_ = p2;
    return tmp;
}

/********************   Stminc    ********************/

Stm make_Stminc(Include p1, Stringval p2)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stminc!\n");
        exit(1);
    }
    tmp->kind = is_Stminc;
    tmp->u.stminc_.include_ = p1;
    tmp->u.stminc_.stringval_ = p2;
    return tmp;
}

/********************   Stmx    ********************/

Stm make_Stmx(DataFlow p1)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmx!\n");
        exit(1);
    }
    tmp->kind = is_Stmx;
    tmp->u.stmx_.dataflow_ = p1;
    return tmp;
}

/********************   Stmn    ********************/

Stm make_Stmn(Numassgn p1)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmn!\n");
        exit(1);
    }
    tmp->kind = is_Stmn;
    tmp->u.stmn_.numassgn_ = p1;
    return tmp;
}

/********************   Stms    ********************/

Stm make_Stms(Strassgn p1)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stms!\n");
        exit(1);
    }
    tmp->kind = is_Stms;
    tmp->u.stms_.strassgn_ = p1;
    return tmp;
}

/********************   Stmb    ********************/

Stm make_Stmb(SymAssgn p1)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmb!\n");
        exit(1);
    }
    tmp->kind = is_Stmb;
    tmp->u.stmb_.symassgn_ = p1;
    return tmp;
}

/********************   Stmh    ********************/

Stm make_Stmh(Hermt p1)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmh!\n");
        exit(1);
    }
    tmp->kind = is_Stmh;
    tmp->u.stmh_.hermt_ = p1;
    return tmp;
}

/********************   Stmnet    ********************/

Stm make_Stmnet(Subdef p1)
{
    Stm tmp = (Stm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Stmnet!\n");
        exit(1);
    }
    tmp->kind = is_Stmnet;
    tmp->u.stmnet_.subdef_ = p1;
    return tmp;
}

/********************   ListStm    ********************/

ListStm make_ListStm(Stm p1, ListStm p2)
{
    ListStm tmp = (ListStm) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListStm!\n");
        exit(1);
    }
    tmp->stm_ = p1;
    tmp->liststm_ = p2;
    return tmp;
}

/********************   Snet    ********************/

Subdef make_Snet(SubId p1, ListSubnet p2)
{
    Subdef tmp = (Subdef) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Snet!\n");
        exit(1);
    }
    tmp->kind = is_Snet;
    tmp->u.snet_.subid_ = p1;
    tmp->u.snet_.listsubnet_ = p2;
    return tmp;
}

/********************   Sneth    ********************/

Subnet make_Sneth(Hermt p1)
{
    Subnet tmp = (Subnet) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Sneth!\n");
        exit(1);
    }
    tmp->kind = is_Sneth;
    tmp->u.sneth_.hermt_ = p1;
    return tmp;
}

/********************   Snets    ********************/

Subnet make_Snets(DataFlow p1)
{
    Subnet tmp = (Subnet) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Snets!\n");
        exit(1);
    }
    tmp->kind = is_Snets;
    tmp->u.snets_.dataflow_ = p1;
    return tmp;
}

/********************   Snetin    ********************/

Subnet make_Snetin(ExtPortIn p1)
{
    Subnet tmp = (Subnet) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Snetin!\n");
        exit(1);
    }
    tmp->kind = is_Snetin;
    tmp->u.snetin_.extportin_ = p1;
    return tmp;
}

/********************   Snetout    ********************/

Subnet make_Snetout(ExtPortOut p1)
{
    Subnet tmp = (Subnet) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Snetout!\n");
        exit(1);
    }
    tmp->kind = is_Snetout;
    tmp->u.snetout_.extportout_ = p1;
    return tmp;
}

/********************   ListSubnet    ********************/

ListSubnet make_ListSubnet(Subnet p1, ListSubnet p2)
{
    ListSubnet tmp = (ListSubnet) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListSubnet!\n");
        exit(1);
    }
    tmp->subnet_ = p1;
    tmp->listsubnet_ = p2;
    return tmp;
}

/********************   Extin    ********************/

ExtPortIn make_Extin(Proc p1, Prt p2, Larrow p3, Tab p4)
{
    ExtPortIn tmp = (ExtPortIn) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Extin!\n");
        exit(1);
    }
    tmp->kind = is_Extin;
    tmp->u.extin_.proc_ = p1;
    tmp->u.extin_.prt_ = p2;
    tmp->u.extin_.larrow_ = p3;
    tmp->u.extin_.tab_ = p4;
    return tmp;
}

/********************   ExtinR    ********************/

ExtPortIn make_ExtinR(Tab p1, Rarrow p2, Prt p3, Proc p4)
{
    ExtPortIn tmp = (ExtPortIn) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ExtinR!\n");
        exit(1);
    }
    tmp->kind = is_ExtinR;
    tmp->u.extinr_.tab_ = p1;
    tmp->u.extinr_.rarrow_ = p2;
    tmp->u.extinr_.prt_ = p3;
    tmp->u.extinr_.proc_ = p4;
    return tmp;
}

/********************   Extout    ********************/

ExtPortOut make_Extout(Tab p1, Larrow p2, Prt p3, Proc p4)
{
    ExtPortOut tmp = (ExtPortOut) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Extout!\n");
        exit(1);
    }
    tmp->kind = is_Extout;
    tmp->u.extout_.tab_ = p1;
    tmp->u.extout_.larrow_ = p2;
    tmp->u.extout_.prt_ = p3;
    tmp->u.extout_.proc_ = p4;
    return tmp;
}

/********************   Extoutr    ********************/

ExtPortOut make_Extoutr(Proc p1, Prt p2, Rarrow p3, Tab p4)
{
    ExtPortOut tmp = (ExtPortOut) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Extoutr!\n");
        exit(1);
    }
    tmp->kind = is_Extoutr;
    tmp->u.extoutr_.proc_ = p1;
    tmp->u.extoutr_.prt_ = p2;
    tmp->u.extoutr_.rarrow_ = p3;
    tmp->u.extoutr_.tab_ = p4;
    return tmp;
}

/********************   Tabn    ********************/

Tab make_Tabn(Numval p1)
{
    Tab tmp = (Tab) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Tabn!\n");
        exit(1);
    }
    tmp->kind = is_Tabn;
    tmp->u.tabn_.numval_ = p1;
    return tmp;
}

/********************   Tabs    ********************/

Tab make_Tabs(Symval p1)
{
    Tab tmp = (Tab) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Tabs!\n");
        exit(1);
    }
    tmp->kind = is_Tabs;
    tmp->u.tabs_.symval_ = p1;
    return tmp;
}

/********************   Streamx    ********************/

DataFlow make_Streamx(Proc p1, Prt p2, Larrow p3, Prt p4, Proc p5)
{
    DataFlow tmp = (DataFlow) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Streamx!\n");
        exit(1);
    }
    tmp->kind = is_Streamx;
    tmp->u.streamx_.proc_1 = p1;
    tmp->u.streamx_.prt_1 = p2;
    tmp->u.streamx_.larrow_ = p3;
    tmp->u.streamx_.prt_2 = p4;
    tmp->u.streamx_.proc_2 = p5;
    return tmp;
}

/********************   Streamrx    ********************/

DataFlow make_Streamrx(Proc p1, Prt p2, Rarrow p3, Prt p4, Proc p5)
{
    DataFlow tmp = (DataFlow) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Streamrx!\n");
        exit(1);
    }
    tmp->kind = is_Streamrx;
    tmp->u.streamrx_.proc_1 = p1;
    tmp->u.streamrx_.prt_1 = p2;
    tmp->u.streamrx_.rarrow_ = p3;
    tmp->u.streamrx_.prt_2 = p4;
    tmp->u.streamrx_.proc_2 = p5;
    return tmp;
}

/********************   Streamy    ********************/

DataFlow make_Streamy(DataFlow p1, Prt p2, Larrow p3, Prt p4, Proc p5)
{
    DataFlow tmp = (DataFlow) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Streamy!\n");
        exit(1);
    }
    tmp->kind = is_Streamy;
    tmp->u.streamy_.dataflow_ = p1;
    tmp->u.streamy_.prt_1 = p2;
    tmp->u.streamy_.larrow_ = p3;
    tmp->u.streamy_.prt_2 = p4;
    tmp->u.streamy_.proc_ = p5;
    return tmp;
}

/********************   Streamry    ********************/

DataFlow make_Streamry(DataFlow p1, Prt p2, Rarrow p3, Prt p4, Proc p5)
{
    DataFlow tmp = (DataFlow) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Streamry!\n");
        exit(1);
    }
    tmp->kind = is_Streamry;
    tmp->u.streamry_.dataflow_ = p1;
    tmp->u.streamry_.prt_1 = p2;
    tmp->u.streamry_.rarrow_ = p3;
    tmp->u.streamry_.prt_2 = p4;
    tmp->u.streamry_.proc_ = p5;
    return tmp;
}

/********************   Arrowx    ********************/

Larrow make_Arrowx(TypeDef p1, Buffsize p2)
{
    Larrow tmp = (Larrow) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Arrowx!\n");
        exit(1);
    }
    tmp->kind = is_Arrowx;
    tmp->u.arrowx_.typedef_ = p1;
    tmp->u.arrowx_.buffsize_ = p2;
    return tmp;
}

/********************   Arrowr    ********************/

Rarrow make_Arrowr(TypeDef p1, Buffsize p2)
{
    Rarrow tmp = (Rarrow) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Arrowr!\n");
        exit(1);
    }
    tmp->kind = is_Arrowr;
    tmp->u.arrowr_.typedef_ = p1;
    tmp->u.arrowr_.buffsize_ = p2;
    return tmp;
}

/********************   Typedefa    ********************/

TypeDef make_Typedefa(Symvalu p1)
{
    TypeDef tmp = (TypeDef) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Typedefa!\n");
        exit(1);
    }
    tmp->kind = is_Typedefa;
    tmp->u.typedefa_.symvalu_ = p1;
    return tmp;
}

/********************   Typedefnull    ********************/

TypeDef make_Typedefnull()
{
    TypeDef tmp = (TypeDef) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Typedefnull!\n");
        exit(1);
    }
    tmp->kind = is_Typedefnull;
    return tmp;
}

/********************   Bufszi    ********************/

Buffsize make_Bufszi(Numval p1)
{
    Buffsize tmp = (Buffsize) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Bufszi!\n");
        exit(1);
    }
    tmp->kind = is_Bufszi;
    tmp->u.bufszi_.numval_ = p1;
    return tmp;
}

/********************   Bufsze    ********************/

Buffsize make_Bufsze()
{
    Buffsize tmp = (Buffsize) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Bufsze!\n");
        exit(1);
    }
    tmp->kind = is_Bufsze;
    return tmp;
}

/********************   Hermtx    ********************/

Hermt make_Hermtx(Symvalu p1, Comp p2, ListArgument p3)
{
    Hermt tmp = (Hermt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Hermtx!\n");
        exit(1);
    }
    tmp->kind = is_Hermtx;
    tmp->u.hermtx_.symvalu_ = p1;
    tmp->u.hermtx_.comp_ = p2;
    tmp->u.hermtx_.listargument_ = p3;
    return tmp;
}

/********************   Hermty    ********************/

Hermt make_Hermty(Symvalu p1, ListArgument p2)
{
    Hermt tmp = (Hermt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Hermty!\n");
        exit(1);
    }
    tmp->kind = is_Hermty;
    tmp->u.hermty_.symvalu_ = p1;
    tmp->u.hermty_.listargument_ = p2;
    return tmp;
}

/********************   Symvaluv    ********************/

Symvalu make_Symvaluv(Symval p1)
{
    Symvalu tmp = (Symvalu) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Symvaluv!\n");
        exit(1);
    }
    tmp->kind = is_Symvaluv;
    tmp->u.symvaluv_.symval_ = p1;
    return tmp;
}

/********************   Symvaluu    ********************/

Symvalu make_Symvaluu()
{
    Symvalu tmp = (Symvalu) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Symvaluu!\n");
        exit(1);
    }
    tmp->kind = is_Symvaluu;
    return tmp;
}

/********************   Processx    ********************/

Proc make_Processx(Symvalu p1, Comp p2, ListArgument p3)
{
    Proc tmp = (Proc) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Processx!\n");
        exit(1);
    }
    tmp->kind = is_Processx;
    tmp->u.processx_.symvalu_ = p1;
    tmp->u.processx_.comp_ = p2;
    tmp->u.processx_.listargument_ = p3;
    return tmp;
}

/********************   Processy    ********************/

Proc make_Processy(Symvalu p1, ListArgument p2)
{
    Proc tmp = (Proc) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Processy!\n");
        exit(1);
    }
    tmp->kind = is_Processy;
    tmp->u.processy_.symvalu_ = p1;
    tmp->u.processy_.listargument_ = p2;
    return tmp;
}

/********************   Portx    ********************/

Prt make_Portx(Numval p1)
{
    Prt tmp = (Prt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Portx!\n");
        exit(1);
    }
    tmp->kind = is_Portx;
    tmp->u.portx_.numval_ = p1;
    return tmp;
}

/********************   Portni    ********************/

Prt make_Portni(Numval p1, Symval p2)
{
    Prt tmp = (Prt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Portni!\n");
        exit(1);
    }
    tmp->kind = is_Portni;
    tmp->u.portni_.numval_ = p1;
    tmp->u.portni_.symval_ = p2;
    return tmp;
}

/********************   Portin    ********************/

Prt make_Portin(Symval p1, Numval p2)
{
    Prt tmp = (Prt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Portin!\n");
        exit(1);
    }
    tmp->kind = is_Portin;
    tmp->u.portin_.symval_ = p1;
    tmp->u.portin_.numval_ = p2;
    return tmp;
}

/********************   Portn    ********************/

Prt make_Portn(Symval p1)
{
    Prt tmp = (Prt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Portn!\n");
        exit(1);
    }
    tmp->kind = is_Portn;
    tmp->u.portn_.symval_ = p1;
    return tmp;
}

/********************   Porte    ********************/

Prt make_Porte()
{
    Prt tmp = (Prt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Porte!\n");
        exit(1);
    }
    tmp->kind = is_Porte;
    return tmp;
}

/********************   Compx    ********************/

Comp make_Compx(Symval p1)
{
    Comp tmp = (Comp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Compx!\n");
        exit(1);
    }
    tmp->kind = is_Compx;
    tmp->u.compx_.symval_ = p1;
    return tmp;
}

/********************   Compn    ********************/

Comp make_Compn(SubId p1)
{
    Comp tmp = (Comp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Compn!\n");
        exit(1);
    }
    tmp->kind = is_Compn;
    tmp->u.compn_.subid_ = p1;
    return tmp;
}

/********************   Compz    ********************/

Comp make_Compz(ModPath p1, Symval p2)
{
    Comp tmp = (Comp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Compz!\n");
        exit(1);
    }
    tmp->kind = is_Compz;
    tmp->u.compz_.modpath_ = p1;
    tmp->u.compz_.symval_ = p2;
    return tmp;
}

/********************   Compa    ********************/

Comp make_Compa(RemPath p1)
{
    Comp tmp = (Comp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Compa!\n");
        exit(1);
    }
    tmp->kind = is_Compa;
    tmp->u.compa_.rempath_ = p1;
    return tmp;
}

/********************   Modpa    ********************/

ModPath make_Modpa(Symval p1)
{
    ModPath tmp = (ModPath) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Modpa!\n");
        exit(1);
    }
    tmp->kind = is_Modpa;
    tmp->u.modpa_.symval_ = p1;
    return tmp;
}

/********************   Modpx    ********************/

ModPath make_Modpx(Symval p1)
{
    ModPath tmp = (ModPath) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Modpx!\n");
        exit(1);
    }
    tmp->kind = is_Modpx;
    tmp->u.modpx_.symval_ = p1;
    return tmp;
}

/********************   Modpy    ********************/

ModPath make_Modpy(ModPath p1, Symval p2)
{
    ModPath tmp = (ModPath) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Modpy!\n");
        exit(1);
    }
    tmp->kind = is_Modpy;
    tmp->u.modpy_.modpath_ = p1;
    tmp->u.modpy_.symval_ = p2;
    return tmp;
}

/********************   Modps    ********************/

ModPath make_Modps(Stringvar p1)
{
    ModPath tmp = (ModPath) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Modps!\n");
        exit(1);
    }
    tmp->kind = is_Modps;
    tmp->u.modps_.stringvar_ = p1;
    return tmp;
}

/********************   RemPatha    ********************/

RemPath make_RemPatha(ValidImport p1, Symval p2)
{
    RemPath tmp = (RemPath) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RemPatha!\n");
        exit(1);
    }
    tmp->kind = is_RemPatha;
    tmp->u.rempatha_.validimport_ = p1;
    tmp->u.rempatha_.symval_ = p2;
    return tmp;
}

/********************   Argumentx    ********************/

Argument make_Argumentx(Stringval p1)
{
    Argument tmp = (Argument) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Argumentx!\n");
        exit(1);
    }
    tmp->kind = is_Argumentx;
    tmp->u.argumentx_.stringval_ = p1;
    return tmp;
}

/********************   ListArgument    ********************/

ListArgument make_ListArgument(Argument p1, ListArgument p2)
{
    ListArgument tmp = (ListArgument) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListArgument!\n");
        exit(1);
    }
    tmp->argument_ = p1;
    tmp->listargument_ = p2;
    return tmp;
}

/********************   NumAssgnv    ********************/

Numassgn make_NumAssgnv(Numvar p1, Numval p2)
{
    Numassgn tmp = (Numassgn) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NumAssgnv!\n");
        exit(1);
    }
    tmp->kind = is_NumAssgnv;
    tmp->u.numassgnv_.numvar_ = p1;
    tmp->u.numassgnv_.numval_ = p2;
    return tmp;
}

/********************   StrAssgnv    ********************/

Strassgn make_StrAssgnv(Stringvar p1, Stringval p2)
{
    Strassgn tmp = (Strassgn) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating StrAssgnv!\n");
        exit(1);
    }
    tmp->kind = is_StrAssgnv;
    tmp->u.strassgnv_.stringvar_ = p1;
    tmp->u.strassgnv_.stringval_ = p2;
    return tmp;
}

/********************   SymAssgni    ********************/

SymAssgn make_SymAssgni(Symvar p1, Symval p2)
{
    SymAssgn tmp = (SymAssgn) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SymAssgni!\n");
        exit(1);
    }
    tmp->kind = is_SymAssgni;
    tmp->u.symassgni_.symvar_ = p1;
    tmp->u.symassgni_.symval_ = p2;
    return tmp;
}

/********************   NumVali    ********************/

Numval make_NumVali(Integer p1)
{
    Numval tmp = (Numval) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NumVali!\n");
        exit(1);
    }
    tmp->kind = is_NumVali;
    tmp->u.numvali_.integer_ = p1;
    return tmp;
}

/********************   NumValv    ********************/

Numval make_NumValv(Numvar p1)
{
    Numval tmp = (Numval) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NumValv!\n");
        exit(1);
    }
    tmp->kind = is_NumValv;
    tmp->u.numvalv_.numvar_ = p1;
    return tmp;
}

/********************   StringVals    ********************/

Stringval make_StringVals(String p1)
{
    Stringval tmp = (Stringval) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating StringVals!\n");
        exit(1);
    }
    tmp->kind = is_StringVals;
    tmp->u.stringvals_.string_ = p1;
    return tmp;
}

/********************   StringValv    ********************/

Stringval make_StringValv(Stringvar p1)
{
    Stringval tmp = (Stringval) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating StringValv!\n");
        exit(1);
    }
    tmp->kind = is_StringValv;
    tmp->u.stringvalv_.stringvar_ = p1;
    return tmp;
}

/********************   StringVale    ********************/

Stringval make_StringVale(Envar p1)
{
    Stringval tmp = (Stringval) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating StringVale!\n");
        exit(1);
    }
    tmp->kind = is_StringVale;
    tmp->u.stringvale_.envar_ = p1;
    return tmp;
}

/********************   Symvalv    ********************/

Symval make_Symvalv(Symvar p1)
{
    Symval tmp = (Symval) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Symvalv!\n");
        exit(1);
    }
    tmp->kind = is_Symvalv;
    tmp->u.symvalv_.symvar_ = p1;
    return tmp;
}

/********************   Symvali    ********************/

Symval make_Symvali(Id p1)
{
    Symval tmp = (Symval) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Symvali!\n");
        exit(1);
    }
    tmp->kind = is_Symvali;
    tmp->u.symvali_.id_ = p1;
    return tmp;
}

/********************   SymVale    ********************/

Symval make_SymVale(Envar p1)
{
    Symval tmp = (Symval) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SymVale!\n");
        exit(1);
    }
    tmp->kind = is_SymVale;
    tmp->u.symvale_.envar_ = p1;
    return tmp;
}

/********************   Inc1    ********************/

Include make_Inc1()
{
    Include tmp = (Include) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Inc1!\n");
        exit(1);
    }
    tmp->kind = is_Inc1;
    return tmp;
}

/********************   Inc2    ********************/

Include make_Inc2()
{
    Include tmp = (Include) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Inc2!\n");
        exit(1);
    }
    tmp->kind = is_Inc2;
    return tmp;
}

/********************   Prefu    ********************/

Prefix make_Prefu()
{
    Prefix tmp = (Prefix) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Prefu!\n");
        exit(1);
    }
    tmp->kind = is_Prefu;
    return tmp;
}

/********************   Prefl    ********************/

Prefix make_Prefl()
{
    Prefix tmp = (Prefix) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Prefl!\n");
        exit(1);
    }
    tmp->kind = is_Prefl;
    return tmp;
}

/********************   Validcfg    ********************/

ValidConfig make_Validcfg(ListEntry p1)
{
    ValidConfig tmp = (ValidConfig) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Validcfg!\n");
        exit(1);
    }
    tmp->kind = is_Validcfg;
    tmp->u.validcfg_.listentry_ = p1;
    return tmp;
}

/********************   Validcfgd    ********************/

ValidConfig make_Validcfgd(ListCentry p1)
{
    ValidConfig tmp = (ValidConfig) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Validcfgd!\n");
        exit(1);
    }
    tmp->kind = is_Validcfgd;
    tmp->u.validcfgd_.listcentry_ = p1;
    return tmp;
}

/********************   CfgcEntrya    ********************/

Centry make_CfgcEntrya(KeyVal p1)
{
    Centry tmp = (Centry) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CfgcEntrya!\n");
        exit(1);
    }
    tmp->kind = is_CfgcEntrya;
    tmp->u.cfgcentrya_.keyval_ = p1;
    return tmp;
}

/********************   CfgcEntryb    ********************/

Centry make_CfgcEntryb(KeyName p1)
{
    Centry tmp = (Centry) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CfgcEntryb!\n");
        exit(1);
    }
    tmp->kind = is_CfgcEntryb;
    tmp->u.cfgcentryb_.keyname_ = p1;
    return tmp;
}

/********************   ListCentry    ********************/

ListCentry make_ListCentry(Centry p1, ListCentry p2)
{
    ListCentry tmp = (ListCentry) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListCentry!\n");
        exit(1);
    }
    tmp->centry_ = p1;
    tmp->listcentry_ = p2;
    return tmp;
}

/********************   CfgEntrya    ********************/

Entry make_CfgEntrya(KeyVal p1)
{
    Entry tmp = (Entry) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CfgEntrya!\n");
        exit(1);
    }
    tmp->kind = is_CfgEntrya;
    tmp->u.cfgentrya_.keyval_ = p1;
    return tmp;
}

/********************   CfgEntryb    ********************/

Entry make_CfgEntryb(KeyName p1)
{
    Entry tmp = (Entry) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CfgEntryb!\n");
        exit(1);
    }
    tmp->kind = is_CfgEntryb;
    tmp->u.cfgentryb_.keyname_ = p1;
    return tmp;
}

/********************   ListEntry    ********************/

ListEntry make_ListEntry(Entry p1, ListEntry p2)
{
    ListEntry tmp = (ListEntry) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListEntry!\n");
        exit(1);
    }
    tmp->entry_ = p1;
    tmp->listentry_ = p2;
    return tmp;
}

/********************   CfgKeyvalint    ********************/

KeyVal make_CfgKeyvalint(KeyName p1, Integer p2)
{
    KeyVal tmp = (KeyVal) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CfgKeyvalint!\n");
        exit(1);
    }
    tmp->kind = is_CfgKeyvalint;
    tmp->u.cfgkeyvalint_.keyname_ = p1;
    tmp->u.cfgkeyvalint_.integer_ = p2;
    return tmp;
}

/********************   CfgKeyvalstr    ********************/

KeyVal make_CfgKeyvalstr(KeyName p1, String p2)
{
    KeyVal tmp = (KeyVal) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CfgKeyvalstr!\n");
        exit(1);
    }
    tmp->kind = is_CfgKeyvalstr;
    tmp->u.cfgkeyvalstr_.keyname_ = p1;
    tmp->u.cfgkeyvalstr_.string_ = p2;
    return tmp;
}

/********************   CfgKeyDate    ********************/

KeyVal make_CfgKeyDate(KeyName p1, Date p2)
{
    KeyVal tmp = (KeyVal) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CfgKeyDate!\n");
        exit(1);
    }
    tmp->kind = is_CfgKeyDate;
    tmp->u.cfgkeydate_.keyname_ = p1;
    tmp->u.cfgkeydate_.date_ = p2;
    return tmp;
}

/********************   KeynameS    ********************/

KeyName make_KeynameS(Symval p1)
{
    KeyName tmp = (KeyName) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating KeynameS!\n");
        exit(1);
    }
    tmp->kind = is_KeynameS;
    tmp->u.keynames_.symval_ = p1;
    return tmp;
}

/********************   KeynameM    ********************/

KeyName make_KeynameM(ModPath p1, Symval p2)
{
    KeyName tmp = (KeyName) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating KeynameM!\n");
        exit(1);
    }
    tmp->kind = is_KeynameM;
    tmp->u.keynamem_.modpath_ = p1;
    tmp->u.keynamem_.symval_ = p2;
    return tmp;
}

/***************************   Cloning   ******************************/

Valide clone_Valide(Valide p)
{
  switch(p->kind)
  {
  case is_CFGvalid:
    return make_CFGvalid (clone_ValidConfig(p->u.cfgvalid_.validconfig_));

  case is_SWvalid:
    return make_SWvalid (clone_ValidSW(p->u.swvalid_.validsw_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Valide!\n");
    exit(1);
  }
}

ValidSW clone_ValidSW(ValidSW p)
{
  switch(p->kind)
  {
  case is_Valid:
    return make_Valid (clone_ListStm(p->u.valid_.liststm_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning ValidSW!\n");
    exit(1);
  }
}

Stm clone_Stm(Stm p)
{
  switch(p->kind)
  {
  case is_StmPrefix:
    return make_StmPrefix
      ( clone_Prefix(p->u.stmprefix_.prefix_)
      , clone_Stringval(p->u.stmprefix_.stringval_)
      );

  case is_Stminc:
    return make_Stminc
      ( clone_Include(p->u.stminc_.include_)
      , clone_Stringval(p->u.stminc_.stringval_)
      );

  case is_Stmx:
    return make_Stmx (clone_DataFlow(p->u.stmx_.dataflow_));

  case is_Stmn:
    return make_Stmn (clone_Numassgn(p->u.stmn_.numassgn_));

  case is_Stms:
    return make_Stms (clone_Strassgn(p->u.stms_.strassgn_));

  case is_Stmb:
    return make_Stmb (clone_SymAssgn(p->u.stmb_.symassgn_));

  case is_Stmh:
    return make_Stmh (clone_Hermt(p->u.stmh_.hermt_));

  case is_Stmnet:
    return make_Stmnet (clone_Subdef(p->u.stmnet_.subdef_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Stm!\n");
    exit(1);
  }
}

ListStm clone_ListStm(ListStm liststm)
{
  if (liststm)
  {
    /* clone of non-empty list */
    return make_ListStm
      ( clone_Stm(liststm->stm_)
      , clone_ListStm(liststm->liststm_)
      );
  }
  else return NULL; /* clone of empty list */
}

Subdef clone_Subdef(Subdef p)
{
  switch(p->kind)
  {
  case is_Snet:
    return make_Snet
      ( strdup(p->u.snet_.subid_)
      , clone_ListSubnet(p->u.snet_.listsubnet_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Subdef!\n");
    exit(1);
  }
}

Subnet clone_Subnet(Subnet p)
{
  switch(p->kind)
  {
  case is_Sneth:
    return make_Sneth (clone_Hermt(p->u.sneth_.hermt_));

  case is_Snets:
    return make_Snets (clone_DataFlow(p->u.snets_.dataflow_));

  case is_Snetin:
    return make_Snetin (clone_ExtPortIn(p->u.snetin_.extportin_));

  case is_Snetout:
    return make_Snetout (clone_ExtPortOut(p->u.snetout_.extportout_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Subnet!\n");
    exit(1);
  }
}

ListSubnet clone_ListSubnet(ListSubnet listsubnet)
{
  if (listsubnet)
  {
    /* clone of non-empty list */
    return make_ListSubnet
      ( clone_Subnet(listsubnet->subnet_)
      , clone_ListSubnet(listsubnet->listsubnet_)
      );
  }
  else return NULL; /* clone of empty list */
}

ExtPortIn clone_ExtPortIn(ExtPortIn p)
{
  switch(p->kind)
  {
  case is_Extin:
    return make_Extin
      ( clone_Proc(p->u.extin_.proc_)
      , clone_Prt(p->u.extin_.prt_)
      , clone_Larrow(p->u.extin_.larrow_)
      , clone_Tab(p->u.extin_.tab_)
      );

  case is_ExtinR:
    return make_ExtinR
      ( clone_Tab(p->u.extinr_.tab_)
      , clone_Rarrow(p->u.extinr_.rarrow_)
      , clone_Prt(p->u.extinr_.prt_)
      , clone_Proc(p->u.extinr_.proc_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ExtPortIn!\n");
    exit(1);
  }
}

ExtPortOut clone_ExtPortOut(ExtPortOut p)
{
  switch(p->kind)
  {
  case is_Extout:
    return make_Extout
      ( clone_Tab(p->u.extout_.tab_)
      , clone_Larrow(p->u.extout_.larrow_)
      , clone_Prt(p->u.extout_.prt_)
      , clone_Proc(p->u.extout_.proc_)
      );

  case is_Extoutr:
    return make_Extoutr
      ( clone_Proc(p->u.extoutr_.proc_)
      , clone_Prt(p->u.extoutr_.prt_)
      , clone_Rarrow(p->u.extoutr_.rarrow_)
      , clone_Tab(p->u.extoutr_.tab_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ExtPortOut!\n");
    exit(1);
  }
}

Tab clone_Tab(Tab p)
{
  switch(p->kind)
  {
  case is_Tabn:
    return make_Tabn (clone_Numval(p->u.tabn_.numval_));

  case is_Tabs:
    return make_Tabs (clone_Symval(p->u.tabs_.symval_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Tab!\n");
    exit(1);
  }
}

DataFlow clone_DataFlow(DataFlow p)
{
  switch(p->kind)
  {
  case is_Streamx:
    return make_Streamx
      ( clone_Proc(p->u.streamx_.proc_1)
      , clone_Prt(p->u.streamx_.prt_1)
      , clone_Larrow(p->u.streamx_.larrow_)
      , clone_Prt(p->u.streamx_.prt_2)
      , clone_Proc(p->u.streamx_.proc_2)
      );

  case is_Streamrx:
    return make_Streamrx
      ( clone_Proc(p->u.streamrx_.proc_1)
      , clone_Prt(p->u.streamrx_.prt_1)
      , clone_Rarrow(p->u.streamrx_.rarrow_)
      , clone_Prt(p->u.streamrx_.prt_2)
      , clone_Proc(p->u.streamrx_.proc_2)
      );

  case is_Streamy:
    return make_Streamy
      ( clone_DataFlow(p->u.streamy_.dataflow_)
      , clone_Prt(p->u.streamy_.prt_1)
      , clone_Larrow(p->u.streamy_.larrow_)
      , clone_Prt(p->u.streamy_.prt_2)
      , clone_Proc(p->u.streamy_.proc_)
      );

  case is_Streamry:
    return make_Streamry
      ( clone_DataFlow(p->u.streamry_.dataflow_)
      , clone_Prt(p->u.streamry_.prt_1)
      , clone_Rarrow(p->u.streamry_.rarrow_)
      , clone_Prt(p->u.streamry_.prt_2)
      , clone_Proc(p->u.streamry_.proc_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning DataFlow!\n");
    exit(1);
  }
}

Larrow clone_Larrow(Larrow p)
{
  switch(p->kind)
  {
  case is_Arrowx:
    return make_Arrowx
      ( clone_TypeDef(p->u.arrowx_.typedef_)
      , clone_Buffsize(p->u.arrowx_.buffsize_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Larrow!\n");
    exit(1);
  }
}

Rarrow clone_Rarrow(Rarrow p)
{
  switch(p->kind)
  {
  case is_Arrowr:
    return make_Arrowr
      ( clone_TypeDef(p->u.arrowr_.typedef_)
      , clone_Buffsize(p->u.arrowr_.buffsize_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Rarrow!\n");
    exit(1);
  }
}

TypeDef clone_TypeDef(TypeDef p)
{
  switch(p->kind)
  {
  case is_Typedefa:
    return make_Typedefa (clone_Symvalu(p->u.typedefa_.symvalu_));

  case is_Typedefnull:
    return make_Typedefnull ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning TypeDef!\n");
    exit(1);
  }
}

Buffsize clone_Buffsize(Buffsize p)
{
  switch(p->kind)
  {
  case is_Bufszi:
    return make_Bufszi (clone_Numval(p->u.bufszi_.numval_));

  case is_Bufsze:
    return make_Bufsze ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Buffsize!\n");
    exit(1);
  }
}

Hermt clone_Hermt(Hermt p)
{
  switch(p->kind)
  {
  case is_Hermtx:
    return make_Hermtx
      ( clone_Symvalu(p->u.hermtx_.symvalu_)
      , clone_Comp(p->u.hermtx_.comp_)
      , clone_ListArgument(p->u.hermtx_.listargument_)
      );

  case is_Hermty:
    return make_Hermty
      ( clone_Symvalu(p->u.hermty_.symvalu_)
      , clone_ListArgument(p->u.hermty_.listargument_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Hermt!\n");
    exit(1);
  }
}

Symvalu clone_Symvalu(Symvalu p)
{
  switch(p->kind)
  {
  case is_Symvaluv:
    return make_Symvaluv (clone_Symval(p->u.symvaluv_.symval_));

  case is_Symvaluu:
    return make_Symvaluu ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Symvalu!\n");
    exit(1);
  }
}

Proc clone_Proc(Proc p)
{
  switch(p->kind)
  {
  case is_Processx:
    return make_Processx
      ( clone_Symvalu(p->u.processx_.symvalu_)
      , clone_Comp(p->u.processx_.comp_)
      , clone_ListArgument(p->u.processx_.listargument_)
      );

  case is_Processy:
    return make_Processy
      ( clone_Symvalu(p->u.processy_.symvalu_)
      , clone_ListArgument(p->u.processy_.listargument_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Proc!\n");
    exit(1);
  }
}

Prt clone_Prt(Prt p)
{
  switch(p->kind)
  {
  case is_Portx:
    return make_Portx (clone_Numval(p->u.portx_.numval_));

  case is_Portni:
    return make_Portni
      ( clone_Numval(p->u.portni_.numval_)
      , clone_Symval(p->u.portni_.symval_)
      );

  case is_Portin:
    return make_Portin
      ( clone_Symval(p->u.portin_.symval_)
      , clone_Numval(p->u.portin_.numval_)
      );

  case is_Portn:
    return make_Portn (clone_Symval(p->u.portn_.symval_));

  case is_Porte:
    return make_Porte ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Prt!\n");
    exit(1);
  }
}

Comp clone_Comp(Comp p)
{
  switch(p->kind)
  {
  case is_Compx:
    return make_Compx (clone_Symval(p->u.compx_.symval_));

  case is_Compn:
    return make_Compn (strdup(p->u.compn_.subid_));

  case is_Compz:
    return make_Compz
      ( clone_ModPath(p->u.compz_.modpath_)
      , clone_Symval(p->u.compz_.symval_)
      );

  case is_Compa:
    return make_Compa (clone_RemPath(p->u.compa_.rempath_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Comp!\n");
    exit(1);
  }
}

ModPath clone_ModPath(ModPath p)
{
  switch(p->kind)
  {
  case is_Modpa:
    return make_Modpa (clone_Symval(p->u.modpa_.symval_));

  case is_Modpx:
    return make_Modpx (clone_Symval(p->u.modpx_.symval_));

  case is_Modpy:
    return make_Modpy
      ( clone_ModPath(p->u.modpy_.modpath_)
      , clone_Symval(p->u.modpy_.symval_)
      );

  case is_Modps:
    return make_Modps (strdup(p->u.modps_.stringvar_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning ModPath!\n");
    exit(1);
  }
}

RemPath clone_RemPath(RemPath p)
{
  switch(p->kind)
  {
  case is_RemPatha:
    return make_RemPatha
      ( strdup(p->u.rempatha_.validimport_)
      , clone_Symval(p->u.rempatha_.symval_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RemPath!\n");
    exit(1);
  }
}

Argument clone_Argument(Argument p)
{
  switch(p->kind)
  {
  case is_Argumentx:
    return make_Argumentx (clone_Stringval(p->u.argumentx_.stringval_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Argument!\n");
    exit(1);
  }
}

ListArgument clone_ListArgument(ListArgument listargument)
{
  if (listargument)
  {
    /* clone of non-empty list */
    return make_ListArgument
      ( clone_Argument(listargument->argument_)
      , clone_ListArgument(listargument->listargument_)
      );
  }
  else return NULL; /* clone of empty list */
}

Numassgn clone_Numassgn(Numassgn p)
{
  switch(p->kind)
  {
  case is_NumAssgnv:
    return make_NumAssgnv
      ( strdup(p->u.numassgnv_.numvar_)
      , clone_Numval(p->u.numassgnv_.numval_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Numassgn!\n");
    exit(1);
  }
}

Strassgn clone_Strassgn(Strassgn p)
{
  switch(p->kind)
  {
  case is_StrAssgnv:
    return make_StrAssgnv
      ( strdup(p->u.strassgnv_.stringvar_)
      , clone_Stringval(p->u.strassgnv_.stringval_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning Strassgn!\n");
    exit(1);
  }
}

SymAssgn clone_SymAssgn(SymAssgn p)
{
  switch(p->kind)
  {
  case is_SymAssgni:
    return make_SymAssgni
      ( strdup(p->u.symassgni_.symvar_)
      , clone_Symval(p->u.symassgni_.symval_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning SymAssgn!\n");
    exit(1);
  }
}

Numval clone_Numval(Numval p)
{
  switch(p->kind)
  {
  case is_NumVali:
    return make_NumVali (p->u.numvali_.integer_);

  case is_NumValv:
    return make_NumValv (strdup(p->u.numvalv_.numvar_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Numval!\n");
    exit(1);
  }
}

Stringval clone_Stringval(Stringval p)
{
  switch(p->kind)
  {
  case is_StringVals:
    return make_StringVals (strdup(p->u.stringvals_.string_));

  case is_StringValv:
    return make_StringValv (strdup(p->u.stringvalv_.stringvar_));

  case is_StringVale:
    return make_StringVale (strdup(p->u.stringvale_.envar_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Stringval!\n");
    exit(1);
  }
}

Symval clone_Symval(Symval p)
{
  switch(p->kind)
  {
  case is_Symvalv:
    return make_Symvalv (strdup(p->u.symvalv_.symvar_));

  case is_Symvali:
    return make_Symvali (strdup(p->u.symvali_.id_));

  case is_SymVale:
    return make_SymVale (strdup(p->u.symvale_.envar_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Symval!\n");
    exit(1);
  }
}

Include clone_Include(Include p)
{
  switch(p->kind)
  {
  case is_Inc1:
    return make_Inc1 ();

  case is_Inc2:
    return make_Inc2 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Include!\n");
    exit(1);
  }
}

Prefix clone_Prefix(Prefix p)
{
  switch(p->kind)
  {
  case is_Prefu:
    return make_Prefu ();

  case is_Prefl:
    return make_Prefl ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Prefix!\n");
    exit(1);
  }
}

ValidConfig clone_ValidConfig(ValidConfig p)
{
  switch(p->kind)
  {
  case is_Validcfg:
    return make_Validcfg (clone_ListEntry(p->u.validcfg_.listentry_));

  case is_Validcfgd:
    return make_Validcfgd (clone_ListCentry(p->u.validcfgd_.listcentry_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning ValidConfig!\n");
    exit(1);
  }
}

Centry clone_Centry(Centry p)
{
  switch(p->kind)
  {
  case is_CfgcEntrya:
    return make_CfgcEntrya (clone_KeyVal(p->u.cfgcentrya_.keyval_));

  case is_CfgcEntryb:
    return make_CfgcEntryb (clone_KeyName(p->u.cfgcentryb_.keyname_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Centry!\n");
    exit(1);
  }
}

ListCentry clone_ListCentry(ListCentry listcentry)
{
  if (listcentry)
  {
    /* clone of non-empty list */
    return make_ListCentry
      ( clone_Centry(listcentry->centry_)
      , clone_ListCentry(listcentry->listcentry_)
      );
  }
  else return NULL; /* clone of empty list */
}

Entry clone_Entry(Entry p)
{
  switch(p->kind)
  {
  case is_CfgEntrya:
    return make_CfgEntrya (clone_KeyVal(p->u.cfgentrya_.keyval_));

  case is_CfgEntryb:
    return make_CfgEntryb (clone_KeyName(p->u.cfgentryb_.keyname_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Entry!\n");
    exit(1);
  }
}

ListEntry clone_ListEntry(ListEntry listentry)
{
  if (listentry)
  {
    /* clone of non-empty list */
    return make_ListEntry
      ( clone_Entry(listentry->entry_)
      , clone_ListEntry(listentry->listentry_)
      );
  }
  else return NULL; /* clone of empty list */
}

KeyVal clone_KeyVal(KeyVal p)
{
  switch(p->kind)
  {
  case is_CfgKeyvalint:
    return make_CfgKeyvalint
      ( clone_KeyName(p->u.cfgkeyvalint_.keyname_)
      , p->u.cfgkeyvalint_.integer_
      );

  case is_CfgKeyvalstr:
    return make_CfgKeyvalstr
      ( clone_KeyName(p->u.cfgkeyvalstr_.keyname_)
      , strdup(p->u.cfgkeyvalstr_.string_)
      );

  case is_CfgKeyDate:
    return make_CfgKeyDate
      ( clone_KeyName(p->u.cfgkeydate_.keyname_)
      , strdup(p->u.cfgkeydate_.date_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning KeyVal!\n");
    exit(1);
  }
}

KeyName clone_KeyName(KeyName p)
{
  switch(p->kind)
  {
  case is_KeynameS:
    return make_KeynameS (clone_Symval(p->u.keynames_.symval_));

  case is_KeynameM:
    return make_KeynameM
      ( clone_ModPath(p->u.keynamem_.modpath_)
      , clone_Symval(p->u.keynamem_.symval_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning KeyName!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Valide(Valide p)
{
  switch(p->kind)
  {
  case is_CFGvalid:
    free_ValidConfig(p->u.cfgvalid_.validconfig_);
    break;

  case is_SWvalid:
    free_ValidSW(p->u.swvalid_.validsw_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Valide!\n");
    exit(1);
  }
  free(p);
}

void free_ValidSW(ValidSW p)
{
  switch(p->kind)
  {
  case is_Valid:
    free_ListStm(p->u.valid_.liststm_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ValidSW!\n");
    exit(1);
  }
  free(p);
}

void free_Stm(Stm p)
{
  switch(p->kind)
  {
  case is_StmPrefix:
    free_Prefix(p->u.stmprefix_.prefix_);
    free_Stringval(p->u.stmprefix_.stringval_);
    break;

  case is_Stminc:
    free_Include(p->u.stminc_.include_);
    free_Stringval(p->u.stminc_.stringval_);
    break;

  case is_Stmx:
    free_DataFlow(p->u.stmx_.dataflow_);
    break;

  case is_Stmn:
    free_Numassgn(p->u.stmn_.numassgn_);
    break;

  case is_Stms:
    free_Strassgn(p->u.stms_.strassgn_);
    break;

  case is_Stmb:
    free_SymAssgn(p->u.stmb_.symassgn_);
    break;

  case is_Stmh:
    free_Hermt(p->u.stmh_.hermt_);
    break;

  case is_Stmnet:
    free_Subdef(p->u.stmnet_.subdef_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Stm!\n");
    exit(1);
  }
  free(p);
}

void free_ListStm(ListStm liststm)
{
  if (liststm)
  {
    free_Stm(liststm->stm_);
    free_ListStm(liststm->liststm_);
    free(liststm);
  }
}

void free_Subdef(Subdef p)
{
  switch(p->kind)
  {
  case is_Snet:
    free(p->u.snet_.subid_);
    free_ListSubnet(p->u.snet_.listsubnet_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Subdef!\n");
    exit(1);
  }
  free(p);
}

void free_Subnet(Subnet p)
{
  switch(p->kind)
  {
  case is_Sneth:
    free_Hermt(p->u.sneth_.hermt_);
    break;

  case is_Snets:
    free_DataFlow(p->u.snets_.dataflow_);
    break;

  case is_Snetin:
    free_ExtPortIn(p->u.snetin_.extportin_);
    break;

  case is_Snetout:
    free_ExtPortOut(p->u.snetout_.extportout_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Subnet!\n");
    exit(1);
  }
  free(p);
}

void free_ListSubnet(ListSubnet listsubnet)
{
  if (listsubnet)
  {
    free_Subnet(listsubnet->subnet_);
    free_ListSubnet(listsubnet->listsubnet_);
    free(listsubnet);
  }
}

void free_ExtPortIn(ExtPortIn p)
{
  switch(p->kind)
  {
  case is_Extin:
    free_Proc(p->u.extin_.proc_);
    free_Prt(p->u.extin_.prt_);
    free_Larrow(p->u.extin_.larrow_);
    free_Tab(p->u.extin_.tab_);
    break;

  case is_ExtinR:
    free_Tab(p->u.extinr_.tab_);
    free_Rarrow(p->u.extinr_.rarrow_);
    free_Prt(p->u.extinr_.prt_);
    free_Proc(p->u.extinr_.proc_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ExtPortIn!\n");
    exit(1);
  }
  free(p);
}

void free_ExtPortOut(ExtPortOut p)
{
  switch(p->kind)
  {
  case is_Extout:
    free_Tab(p->u.extout_.tab_);
    free_Larrow(p->u.extout_.larrow_);
    free_Prt(p->u.extout_.prt_);
    free_Proc(p->u.extout_.proc_);
    break;

  case is_Extoutr:
    free_Proc(p->u.extoutr_.proc_);
    free_Prt(p->u.extoutr_.prt_);
    free_Rarrow(p->u.extoutr_.rarrow_);
    free_Tab(p->u.extoutr_.tab_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ExtPortOut!\n");
    exit(1);
  }
  free(p);
}

void free_Tab(Tab p)
{
  switch(p->kind)
  {
  case is_Tabn:
    free_Numval(p->u.tabn_.numval_);
    break;

  case is_Tabs:
    free_Symval(p->u.tabs_.symval_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Tab!\n");
    exit(1);
  }
  free(p);
}

void free_DataFlow(DataFlow p)
{
  switch(p->kind)
  {
  case is_Streamx:
    free_Proc(p->u.streamx_.proc_1);
    free_Prt(p->u.streamx_.prt_1);
    free_Larrow(p->u.streamx_.larrow_);
    free_Prt(p->u.streamx_.prt_2);
    free_Proc(p->u.streamx_.proc_2);
    break;

  case is_Streamrx:
    free_Proc(p->u.streamrx_.proc_1);
    free_Prt(p->u.streamrx_.prt_1);
    free_Rarrow(p->u.streamrx_.rarrow_);
    free_Prt(p->u.streamrx_.prt_2);
    free_Proc(p->u.streamrx_.proc_2);
    break;

  case is_Streamy:
    free_DataFlow(p->u.streamy_.dataflow_);
    free_Prt(p->u.streamy_.prt_1);
    free_Larrow(p->u.streamy_.larrow_);
    free_Prt(p->u.streamy_.prt_2);
    free_Proc(p->u.streamy_.proc_);
    break;

  case is_Streamry:
    free_DataFlow(p->u.streamry_.dataflow_);
    free_Prt(p->u.streamry_.prt_1);
    free_Rarrow(p->u.streamry_.rarrow_);
    free_Prt(p->u.streamry_.prt_2);
    free_Proc(p->u.streamry_.proc_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing DataFlow!\n");
    exit(1);
  }
  free(p);
}

void free_Larrow(Larrow p)
{
  switch(p->kind)
  {
  case is_Arrowx:
    free_TypeDef(p->u.arrowx_.typedef_);
    free_Buffsize(p->u.arrowx_.buffsize_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Larrow!\n");
    exit(1);
  }
  free(p);
}

void free_Rarrow(Rarrow p)
{
  switch(p->kind)
  {
  case is_Arrowr:
    free_TypeDef(p->u.arrowr_.typedef_);
    free_Buffsize(p->u.arrowr_.buffsize_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Rarrow!\n");
    exit(1);
  }
  free(p);
}

void free_TypeDef(TypeDef p)
{
  switch(p->kind)
  {
  case is_Typedefa:
    free_Symvalu(p->u.typedefa_.symvalu_);
    break;

  case is_Typedefnull:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TypeDef!\n");
    exit(1);
  }
  free(p);
}

void free_Buffsize(Buffsize p)
{
  switch(p->kind)
  {
  case is_Bufszi:
    free_Numval(p->u.bufszi_.numval_);
    break;

  case is_Bufsze:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Buffsize!\n");
    exit(1);
  }
  free(p);
}

void free_Hermt(Hermt p)
{
  switch(p->kind)
  {
  case is_Hermtx:
    free_Symvalu(p->u.hermtx_.symvalu_);
    free_Comp(p->u.hermtx_.comp_);
    free_ListArgument(p->u.hermtx_.listargument_);
    break;

  case is_Hermty:
    free_Symvalu(p->u.hermty_.symvalu_);
    free_ListArgument(p->u.hermty_.listargument_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Hermt!\n");
    exit(1);
  }
  free(p);
}

void free_Symvalu(Symvalu p)
{
  switch(p->kind)
  {
  case is_Symvaluv:
    free_Symval(p->u.symvaluv_.symval_);
    break;

  case is_Symvaluu:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Symvalu!\n");
    exit(1);
  }
  free(p);
}

void free_Proc(Proc p)
{
  switch(p->kind)
  {
  case is_Processx:
    free_Symvalu(p->u.processx_.symvalu_);
    free_Comp(p->u.processx_.comp_);
    free_ListArgument(p->u.processx_.listargument_);
    break;

  case is_Processy:
    free_Symvalu(p->u.processy_.symvalu_);
    free_ListArgument(p->u.processy_.listargument_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Proc!\n");
    exit(1);
  }
  free(p);
}

void free_Prt(Prt p)
{
  switch(p->kind)
  {
  case is_Portx:
    free_Numval(p->u.portx_.numval_);
    break;

  case is_Portni:
    free_Numval(p->u.portni_.numval_);
    free_Symval(p->u.portni_.symval_);
    break;

  case is_Portin:
    free_Symval(p->u.portin_.symval_);
    free_Numval(p->u.portin_.numval_);
    break;

  case is_Portn:
    free_Symval(p->u.portn_.symval_);
    break;

  case is_Porte:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Prt!\n");
    exit(1);
  }
  free(p);
}

void free_Comp(Comp p)
{
  switch(p->kind)
  {
  case is_Compx:
    free_Symval(p->u.compx_.symval_);
    break;

  case is_Compn:
    free(p->u.compn_.subid_);
    break;

  case is_Compz:
    free_ModPath(p->u.compz_.modpath_);
    free_Symval(p->u.compz_.symval_);
    break;

  case is_Compa:
    free_RemPath(p->u.compa_.rempath_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Comp!\n");
    exit(1);
  }
  free(p);
}

void free_ModPath(ModPath p)
{
  switch(p->kind)
  {
  case is_Modpa:
    free_Symval(p->u.modpa_.symval_);
    break;

  case is_Modpx:
    free_Symval(p->u.modpx_.symval_);
    break;

  case is_Modpy:
    free_ModPath(p->u.modpy_.modpath_);
    free_Symval(p->u.modpy_.symval_);
    break;

  case is_Modps:
    free(p->u.modps_.stringvar_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ModPath!\n");
    exit(1);
  }
  free(p);
}

void free_RemPath(RemPath p)
{
  switch(p->kind)
  {
  case is_RemPatha:
    free(p->u.rempatha_.validimport_);
    free_Symval(p->u.rempatha_.symval_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RemPath!\n");
    exit(1);
  }
  free(p);
}

void free_Argument(Argument p)
{
  switch(p->kind)
  {
  case is_Argumentx:
    free_Stringval(p->u.argumentx_.stringval_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Argument!\n");
    exit(1);
  }
  free(p);
}

void free_ListArgument(ListArgument listargument)
{
  if (listargument)
  {
    free_Argument(listargument->argument_);
    free_ListArgument(listargument->listargument_);
    free(listargument);
  }
}

void free_Numassgn(Numassgn p)
{
  switch(p->kind)
  {
  case is_NumAssgnv:
    free(p->u.numassgnv_.numvar_);
    free_Numval(p->u.numassgnv_.numval_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Numassgn!\n");
    exit(1);
  }
  free(p);
}

void free_Strassgn(Strassgn p)
{
  switch(p->kind)
  {
  case is_StrAssgnv:
    free(p->u.strassgnv_.stringvar_);
    free_Stringval(p->u.strassgnv_.stringval_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Strassgn!\n");
    exit(1);
  }
  free(p);
}

void free_SymAssgn(SymAssgn p)
{
  switch(p->kind)
  {
  case is_SymAssgni:
    free(p->u.symassgni_.symvar_);
    free_Symval(p->u.symassgni_.symval_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing SymAssgn!\n");
    exit(1);
  }
  free(p);
}

void free_Numval(Numval p)
{
  switch(p->kind)
  {
  case is_NumVali:
    break;

  case is_NumValv:
    free(p->u.numvalv_.numvar_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Numval!\n");
    exit(1);
  }
  free(p);
}

void free_Stringval(Stringval p)
{
  switch(p->kind)
  {
  case is_StringVals:
    free(p->u.stringvals_.string_);
    break;

  case is_StringValv:
    free(p->u.stringvalv_.stringvar_);
    break;

  case is_StringVale:
    free(p->u.stringvale_.envar_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Stringval!\n");
    exit(1);
  }
  free(p);
}

void free_Symval(Symval p)
{
  switch(p->kind)
  {
  case is_Symvalv:
    free(p->u.symvalv_.symvar_);
    break;

  case is_Symvali:
    free(p->u.symvali_.id_);
    break;

  case is_SymVale:
    free(p->u.symvale_.envar_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Symval!\n");
    exit(1);
  }
  free(p);
}

void free_Include(Include p)
{
  switch(p->kind)
  {
  case is_Inc1:
    break;

  case is_Inc2:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Include!\n");
    exit(1);
  }
  free(p);
}

void free_Prefix(Prefix p)
{
  switch(p->kind)
  {
  case is_Prefu:
    break;

  case is_Prefl:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Prefix!\n");
    exit(1);
  }
  free(p);
}

void free_ValidConfig(ValidConfig p)
{
  switch(p->kind)
  {
  case is_Validcfg:
    free_ListEntry(p->u.validcfg_.listentry_);
    break;

  case is_Validcfgd:
    free_ListCentry(p->u.validcfgd_.listcentry_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ValidConfig!\n");
    exit(1);
  }
  free(p);
}

void free_Centry(Centry p)
{
  switch(p->kind)
  {
  case is_CfgcEntrya:
    free_KeyVal(p->u.cfgcentrya_.keyval_);
    break;

  case is_CfgcEntryb:
    free_KeyName(p->u.cfgcentryb_.keyname_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Centry!\n");
    exit(1);
  }
  free(p);
}

void free_ListCentry(ListCentry listcentry)
{
  if (listcentry)
  {
    free_Centry(listcentry->centry_);
    free_ListCentry(listcentry->listcentry_);
    free(listcentry);
  }
}

void free_Entry(Entry p)
{
  switch(p->kind)
  {
  case is_CfgEntrya:
    free_KeyVal(p->u.cfgentrya_.keyval_);
    break;

  case is_CfgEntryb:
    free_KeyName(p->u.cfgentryb_.keyname_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Entry!\n");
    exit(1);
  }
  free(p);
}

void free_ListEntry(ListEntry listentry)
{
  if (listentry)
  {
    free_Entry(listentry->entry_);
    free_ListEntry(listentry->listentry_);
    free(listentry);
  }
}

void free_KeyVal(KeyVal p)
{
  switch(p->kind)
  {
  case is_CfgKeyvalint:
    free_KeyName(p->u.cfgkeyvalint_.keyname_);
    break;

  case is_CfgKeyvalstr:
    free_KeyName(p->u.cfgkeyvalstr_.keyname_);
    free(p->u.cfgkeyvalstr_.string_);
    break;

  case is_CfgKeyDate:
    free_KeyName(p->u.cfgkeydate_.keyname_);
    free(p->u.cfgkeydate_.date_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing KeyVal!\n");
    exit(1);
  }
  free(p);
}

void free_KeyName(KeyName p)
{
  switch(p->kind)
  {
  case is_KeynameS:
    free_Symval(p->u.keynames_.symval_);
    break;

  case is_KeynameM:
    free_ModPath(p->u.keynamem_.modpath_);
    free_Symval(p->u.keynamem_.symval_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing KeyName!\n");
    exit(1);
  }
  free(p);
}

