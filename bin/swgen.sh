#!/bin/bash

function Debug() {
        [ "$DEBUG" == "Y" ] && echo -e "${yellow}$pgm/DEBUG: $* $reset" 
} 

init() {
    #pgm=swgen_none.sh
    fmt=""
    pgm=$(basename "$0")
    version="0.3.1"
    # HTML=fbpgo.html
    export modpath="$GOPATH/src"

             black="\u001b[30m"
               red="\u001b[31m"
             green="\u001b[32m"
            yellow="\u001b[33m"
              blue="\u001b[34m"
           magenta="\u001b[35m"
              cyan="\u001b[36m"
             white="\u001b[37m"
             reset="\u001b[0m"   
        lightgreen="\u001b[32;1m"

    Debug INIT: Running "$pgm-v$version w/DEBUG.  Args: $* "
    src=/usr/local/src
    [ -d $src ] || Die Cannot find directory $src

    lb='{'
    rb='}'
    for="for"
}


      
Die() {
                echo -e "$red$pgm/DIE: $* $reset"
                exit 1
}

FAIL() { 
	echo "$0/FAIL: $*"
	exit 1
}
	
IdSkel() {
        cat << EOF
        /*  Generated StreamWork component, $name, 
            by $pgm on `date` 
                $inp  input  ports 
                $outp output ports 
        */ 
EOF
}

GenOutP1() {
	Debug GenOutP1
	cat <<- EOF >> "${name}.go" 
	$routine ${pfx}Send(${tchannelMap[[$outp]]}, &_wg2)
EOF

}

GenInP1() {
	cat <<- EOF >> "${name}".go 
	$routine ${pfx}Recv(${tchannelMap[$inp]}, &_wg2, arg, $inp)
EOF

}
 
GenOutP() {      
         if [ "$outp" -eq 1 ]; then 
                cat << EOFX >> "${name}".go       
                
	 // $name: outp=$outp; inp=$inp; po=$po
                        cs[$inp] <- $inp
                        
EOFX
         else   
                
                msg="$pkg/$name $((po-1))"
                cat << EOFX >> "${name}".go
                
                i := $po-1
                
                $for i >= $inp $lb
                        ${tchannelMap[i]} <- "$msg" 
                        close(${tchannelMap[i]})
                        i--
                $rb

EOFX
        fi
}

makeYAML() {
	Debug FAIL makeYAML "$@" 
        cat <<- EOF > $1
# $HOME/.sw/${pkg}.yaml
#    generated by swgen.sh `date`
---
global:                 # Options for all components in $pkg
  buffersize: 0         # Integer example.
  seqno: 1237          # Used to check for valid config file.
EOF
        
}

concatYAML() {
        Debug concatYAML $1 at `pwd`
        
        # yamllint <(( echo $module/${pkg}: ))
        cat <<- EOF >> $1
$module/${pkg}:
  bornon: `date -I'seconds'`
  title: "${cyan}Module:$module Pkg:$pkg${reset}"
  seqno: 1234   # Used to check for valid config file.
  buffersize: 1  # Integer example.
EOF
}

genPkgYAML() {  
    Debug genPkgYAML Args: $*
        
    args=" "
    getargs=""

    allargs=($*) 
	i=${#allargs[@]}  
        
    while [ $i -gt 1 ]; do 
        
	arg=${allargs[$(($i-2))]}
        val=${allargs[$(($i-1))]}
        
	Debug i=$i  arg=$arg val=$val
	
	getargs="$arg, _ := cfg.StringOr(\"$module/${pkg}.$arg\", \"$val\")
	$getargs" 
        
	args="fmt.Print(\"; $arg=\",$arg)  
	$args" 
	
	i=$(($i-2))
	
    done
     	
	Debug make args $*
}      
   
makeCtype() {
	ctype="$1"
	iptype="$1"
	if [ "$1" == "_" ]; then 
		ctype="interface{}"
		iptype="ipT"
	fi
	if [ "$1" == "interface\{\}" ]; then 
		ctype="interface{}"
		iptype="ipT"
	fi
}
   
makeSlice() {
		Debug makeSlice $dn $ncs
		si=0;  #Slice index
		chnlTypes="$chnlTypes, _cs$ncs []chan $ctype"	
	  channelMap[$dn]="_cs$ncs[0]"
	  tlast=${types[$dn]}
	  dn=$(($dn+1)) 
	  rem=$((nt-dn))
	  t1=${types[$dn]}
	  		
	  Debug MS: rem=$rem t1=$t1	 tlast=$tlast	
	  while [ $rem -gt 0 ] && [ "$t1" == "$tlast" ]; do
	  		si=$((si+1))
	  		channelMap[$dn]="_cs$ncs[$si]"
	  		dn=$(($dn+1))
	  	  t1=${types[$dn]}
	  		rem=$((nt-dn))
	  done
	  
	  ncs=$((ncs+1))	
	  Debug makeSlice end,  dn=$dn  
}   

makeChnlTypes() {   
    Debug makeChanlTypes types = "${types[*]}" directs = "${directs[*]}"
    chnlTypes=""
    dn=0
    ncs=0
    
    
    nt=${#types[*]} ; # Number of array elements
    
    while [ $dn -lt $nt ]; do
    		chan="chan<-"
    	  if [ "${directs[$dn]}" == "I" ]; then 
    	  		chan="<-chan"
	    	fi
	    	rem=$((nt-dn))
	    	nexttypen=$((dn+1))
	    	t1="${types[$dn]}"
	    	t2="${types[$nexttypen]}"
	    	Debug rem=$rem $t1/$t2  dn=$dn
	    	makeCtype "${types[$dn]}"
	    	if  [ $rem -gt 1 ] && [ "$t1" == "$t2" ]  ; then
	    				 makeSlice
	    	else 
	    		chnlTypes="$chnlTypes, _ch$dn $chan $ctype"
	    		channelMap[$dn]="_ch$dn"
	    		dn=$((dn+1))
	      fi		
    done
	    	
} 

makeRecvFunc() {
	 	 		 		cat <<- EOF >> $name.go
	 	 		 
	 	 		 		go func() {
	 	 		 		defer _wg2.Done()
	 	 		 		for {
	 	 		 			ip, ok := <- ${channelMap[$ct]}
	 	 		 			if ok != true {
	 	 		 			return 
	 	 		 		}		   
	 	 		 		fmt.Println( arg[0],  "received:", ip)
	 	 		 }
	}()		
	 	 		 			
EOF
}

makeSendFunc() {
	 					makeCtype $typ
	 	 		 		cat <<- EOF >> $name.go
 
	go func() {
	 	defer close(${channelMap[$ct]})
	 	defer _wg2.Done()
	  ip  :=  $iptype{arg[0],"$ctype",271828}
 		${channelMap[$ct]}   <- ip 
	  ip   =  $iptype{arg[0],"pi",314159}
 		${channelMap[$ct]}   <- ip 
	}()
	 	 		 		  
EOF
}
  

genGoCalls() {	
	Debug Gen genGoCalls ${types[*]} ${directs[*]} 	     
	nt=${#types[*]}  
	ct=0	
	 	 		  
	while [ $ct -lt $nt ]; do
	 	 		   cn=$ct
	 	 		   if [ ${directs[$ct]} == "I" ]; then 	
	 	 		      makeRecvFunc
	 	 		   else   
	 	 		   	  makeSendFunc
	 	 		   fi
	 	 		   ct=$(($ct+1))
  done
}	   

# Generate component code
GenGo() {       
	
    makeChnlTypes
    
    nports=$(($inps + $outps))
    Debug GenGo-a $name $* $config  $inps $outps  $nports $cfg_file
	 
         cat <<- EOF > ${name}.go 
    package $pkg2
                
    `IdSkel` 
                 
    import (
        $fmt
        "sync"
    )
             
		// $name is @todo undocumented
    func $name(wg *sync.WaitGroup, arg []string $chnlTypes ){
                
        defer wg.Done()
        Debug("$name running with DEBUG=Y")
        $go_config3
        var _wg2 sync.WaitGroup
        _wg2.Add($nports)
EOF
	    
	 genGoCalls
	 
	 cat <<- EOF >> ${name}.go
	 _wg2.Wait()
	 Debug( "$name Ended" ) 
}		        	
EOF

   gofmt -w -s ${name}.go
}

GenTestOutP() {         
                cat << EOFX >> ${name}_test.go
                
                i := $ni
                $for i >= 0 $lb
                        ${tchannelMap[i]} <- i
                        close(${tchannelMap[i]})
                        i--
                $rb
EOFX
}

makeSend() {
		  cat <<- EOF >> ${name}_test.go
		  
		  go func() {                 
          defer wg.Done()              
          defer close(${tchannelMap[$cn]})
          ip := ${iptype}{"${name}_test", "$ct", 711}   
          ${tchannelMap[$cn]} <- ip
      }()

EOF
}

makeRecv() {
		  cat <<- EOF >> ${name}_test.go
	 
		  go func() {                  
		    defer wg.Done()
		    for {
		     	ip, ok := <- ${tchannelMap[$cn]}
		    	if ok != true {
		    	 	return
		    	}
		      fmt.Println("${name}_test", "received:", ip)
		    }	
		  }()
EOF
}

# Create Send/Recv test msg functions:
makeGoFuncs() {
  Debug makeGoFuncs ${types[*]}
	cn=0
	for ct in ${types[*]}; do
	  Debug MGF ct=$ct
	  makeCtype $ct
	  if [ ${directs[$cn]} == "I" ]; then
		  makeSend
		else
			makeRecv  
    fi  
    cn=$(($cn+1))
  done
}

makeTestSlice() {	    
	  	Debug makeTestSlice: ncn=$ncn ncs=$ncs
	  	si=0
	  	echo "var cs$ncs []chan $ctype" >> ${name}_test.go
	  	echo "cs$ncs=append(cs$ncs,ch$cn)" >> ${name}_test.go
	  	tchannelMap[$cn]="cs$ncs[0]"
	  	channels="$channels, cs$ncs "
	  	lastType=${types[$cn]}
	  			cn=$(($cn+1))
	  		  t1=${types[$cn]}
	  		  rem=$((ncn-cn))
	  	
	  	while [ $rem -gt 0 ] && [ $t1 == $lastType  ]; do  
	  	    Debug MTS: cn=$cn t1=$t1 LT=$lastType 
		  		echo "ch$cn := make(chan $ctype)"  >> ${name}_test.go
	  		  echo "cs$ncs=append(cs$ncs,ch$cn)" >> ${name}_test.go
	  		  si=$((si+1))
	  		  tchannelMap[$cn]="cs$ncs[$si]"
	  			cn=$(($cn+1))
	  		  t1=${types[$cn]}
	  		  rem=$((ncn-cn))
	    done;
	    
	    ncs=$(($ncs+1))
}	    

# Create list of  channels in $channels 
makeTestChannels() {
	Debug makeTestChannels
	echo "" >> ${name}_test.go
	channels=""
	cn=0;		  # Current channel number
	ntcs=0;   # Number of slices
	ncn=${#types[*]}; # Number of channels equals Number of types in cmd
	ncs=0;		# Current slice number
	while [ $cn -lt $ncn ]; do
		ct=${types[$cn]}
	  makeCtype $ct
	  t1=${types[$cn]}
	  t2=${types[$((cn+1))]}
		echo "ch$cn := make(chan $ctype)" >> ${name}_test.go
    si=0;			# Slice index
	  if [ $((ncn - cn)) -gt 1 ] && [ $t1 == $t2 ]; then
	    makeTestSlice
	  else
			channels="$channels, ch$cn "
			tchannelMap[$cn]="ch$cn" 
	    cn=$(($cn+1))
	  fi		
	done 
	
  echo "wg.Add($(($nports+1)) )" >>  ${name}_test.go
	makeGoFuncs  
	
}

forEachInput() {			  
                        # For each input port, receive one ip.
         if [ $no -gt  0 ]; then
                no=$(($no-1))
                po=$(($no+$ni))
                cat << EOFZ >> ${name}_test.go  
 
                j := $po
                $for j >= $ni $lb
                        ip, ok := <- ${tchannelMap[j]}
                        if ok != true {
                                break
                        }
                        fmt.Println("chan:",j,"IP:",ip);
                j--
            $rb   
              
EOFZ
         fi
}  
   
forEachOutput() {      
     if [ $ni -gt 0 ];  then
        ni=$(($ni-1))
                GenTestOutP
     fi
                    #    wg.Done()
                    #    return
       # }() 
}

GenTestGo() {   
         ni=$1
         no=$2
	 Debug GenTestGo $name $ni $no
	 inp=$ni; outp=$no
         cat << EOFY > ${name}_test.go
                package $pkg2

	
        `IdSkel`
        
import "testing"
import "fmt"
import "sync"

func TestSkel_${name}(t *testing.T) {
        var wg  sync.WaitGroup
        
        arg := []string{"${name}"}
        
        fmt.Println(arg[0])
EOFY
   
    nports=$(($no + $ni))
        
 				makeTestChannels;  
 				
			 # forEachInput ?? remove
       # forEachOutput ?? remove
         
     cat << EOFY >> ${name}_test.go
        
        go $name(&wg, arg $channels)
        wg.Wait() 
        
        fmt.Println("Test_${name} Ended")
  }             
EOFY
       go fmt ${name}_test.go
}

GenYamlGo() {
    Debug GenYamlGo $*
    fmt="\"fmt\""
    go_config='config "github.com/zpatrick/go-config"'      
        go_config2="$fconfig"
        go_config3="cfg := ${pfx}PkgConfig()
    bs, _ := cfg.IntOr(\"$module/${pkg}.buffersize\", 1)
    seqno, _ := cfg.IntOr(\"$module/${pkg}.seqno\", 1)
    title, _ := cfg.StringOr(\"$module/${pkg}.title\", \"n/a\")
    version := \"v0.0.0\"
    
    fmt.Println(title, 
                \"${cyan}Running\", 
                arg[0],\"-\",  
                \"$name\",
                version, 
                \"bs =\", bs, 
                \"seqno = \", seqno,\"$reset\") 
    
    if seqno != 1234 {
        fmt.Println(
          \"$module/${pkg}/$name: Seqno is, seqno, not = 1234.  Missing config file?\")
    } 
    "   
    GenGo $*
    concatYAML $cfg_file
}

GenYamlTestGo() {
    GenTestGo $*
}
         
Fail() {
	echo -e Usage: $pgm gs MODULE PACKAGE CONFIG_TYPE INPORTS OUTPORTS Component [ARG VAL]...
	Die $*
}
        
makePkg2() {
	pkg2=`basename $pkg`
}
 
	# Find ROOT in ROOT/.../... 	
GetRoot() {
	p2=$1
		newPkg="`basename $p2`"
		pkgroot=$p2
		p2="`dirname $pkgroot`"
	while [ "$p2" != "." ]; do 
		pkgroot=$p2
		p2="`dirname $pkgroot`"
	done			
}
  
FixPkg() {
    Debug FixPkg
	dn="`basename $pkg`"  
	[ "$dn" == "$module" ] && pkg="`basename $pkg`" && NULLIT="// " || pfx="${module}."
	
	# Change pkg = $module/..../pkg2 to .../pkg2
        GetRoot $pkg
        Debug FixPkg: pkg=$pkg pkgroot=$pkgroot module=$module
        if [ "$module" != "$pkgroot" ]; then
        	foreign=1;  return
        fi 
        foreign=0	
}
 
createTypes() {
	Debug createTypes ${types[*]}
	for typ in ${types[*]}; do
	   makeCtype $typ
		 if [ ! -f "${iptype}.go" ]; then 
		 	 cat << EOF >	"${iptype}.go"
package $module	

import "fmt"

// $iptype Generated by swgen.sh  
type $iptype struct {
		Id string
		Key string
		Value int
}

// Stringer stringifies $iptype structures for functions like fmt.Println
func (_ip $iptype) String() string {
	_bfr := fmt.Sprintf("{%s:%s:%d}", _ip.Id, _ip.Key, _ip.Value) 
	return _bfr
}
		
EOF
		   
		 fi
  done		 
}
 
genConfigGO() {       	 	
	Debug genConfigGO
	createTypes
       	cat <<- EOF > config.go
package $module

/* Generated by $pgm-$version */	 
import "fmt"
import "os"

const (
	yellow string = "\u001b[33m"
	reset  string = "\u001b[0m"
)

func Debug(s string) {
 	if os.Getenv("DEBUG") == "Y" {
 	 	fmt.Print(yellow)
 	 	fmt.Println("config.go/DEBUG:",s,reset)
 	} 
} 	

	func init() {
		os.Setenv("DEBUG","Y")
	}	
					 
EOF
}        
 
tpNotIntypesd() {
	for t in $typesd; do 
		if [ "$t" == "$tp" ]; then 
			dupe="Y"
			return
		fi	
	done 
	typesd="$tp $typesd"
	dupe="N"
} 

GenerateTypesx() {
	Debug GenerateTypes ${types[*]}
	typesd=""
	for tp in ${types[*]}; do 
		Debug GTx: $tp
		tpNotIntypesd
		if [ "$dupe" == "N" ]; then 
		   Debug GT: $tp typesd=$typesd
		   genTypes="type $tp struct {
		   Id string
		   Key string
		   Value int
}

$genTypes"
		fi
	done
	
	Debug GenerateTypes: typesd=$typesd

}
  
SetTypesArgs() {
	Debug SetTypesArgs $*
  typesx=""
  directsx=""
	inps=0; outps=0
	nt=0
	while  [ ! -z $1 ]  ; do
		if [ "$1" == "-i" ]; then 
			directs[$nt]="I";	
			shift 1
			typesx="${typesx}$1 "
			inps=$(($inps+1))
		elif [ "$1" == "-o" ]; then
			directs[$nt]="O";	
			shift 1
			typesx="${typesx}$1 "
			outps=$(($outps+1))
		else
			args=($*)
			shift $#	
		fi 
		nt=$(($nt+1)) 	    
		shift 1
	done
	
	types=($typesx)
	# directs=${directsx}
}

#  Generate a skeleton component w/YAML   
GenYamlSkel() {
    config=$3
    Debug GenYamlSkel config=$config $*
	module=$1;shift;
        pkg=$1; 
        FixPkg
        if [ $foreign -eq 1 ]; then 
        	return
        fi  
        pkg=$newPkg
	Debug GenYamlSkel/FixPkg pfx=$pfx dn=$dn module=$module
        config=$2;  # NONE, TOML, YAML, other later maybe
        name=$3
        
       shift 3
       SetTypesArgs $*
       Debug GenYamlSkel: name=$name directs=\"$directs\" types=\"${types[*]}\" args=\"${args[*]}\" inps=$inps outps=$outps

       
        cfg_file="$src/$module/${module}.yaml"
        [ -z $module ] 	&& Fail Missing module
        [ -z $pkg ] 	&& Fail Missing package 
        [ -z $name ] 	&& Fail Missing name 
        mdl=$module
        [ "$module" == "$pkg" ] && mdl=".";  Debug mdl=$mdl pkg=$pkg
        [ -d $src/$mdl/$pkg ]       		 \
        	|| mkdir -p $src/$mdl/$pkg    \
        	|| Die Cannot create $src/$mdl/$pkg.
        src2=$src/$mdl/$pkg

    pushd $src/$module
                genPkgYAML   ; # ?? $*
        	Debug GenYamlSkel/GenConfig.go `pwd` genTypes=$genTypes
		createTypes
       	 	[ -f config.go ] ||   \
       	 		cat <<- EOF > config.go
package $module

/* Generated by swgen.sh-v$version */	      	 		
import config "github.com/zpatrick/go-config"
import "fmt"
import "os"  	 	

const (
	yellow string = "\u001b[33m"
	reset  string = "\u001b[0m"
)

func Debug(s string) {
 	if os.Getenv("DEBUG") == "Y" {
 	 	fmt.Print(yellow)
 	 	fmt.Println("config.go/DEBUG:",s,reset)
 	} 
} 	

func init() {
 	os.Setenv("DEBUG","Y")
}
 				
// PkgConfig initializes the go-config package.  See: https://github.com/zpatrick/go-config for details.
func PkgConfig()  *config.Config {
        mappings := map[string]string{
                "${pkg^^}_BUFFERSIZE": "${pkg}.buffersize",
                "SEQNO":      "seqno=7",
        }
        
        return config.NewConfig([]config.Provider  {
                config.New${config}File("$src/$pkg/${module}.yaml"), 
                config.NewEnvironment(mappings)} )      
}
			 
EOF


    pushd $src2 || Die Cannot cd  $src2
        Debug GenYamlSkel/subdir `pwd`
        cfg_file="$src/$module/${module}.yaml" 
        [ -f $cfg_file ] || makeYAML $cfg_file
        # inps=$inp;outps=$outp
        	makePkg2
        	Debug `pwd` name: $name $inps $outps ${types[*]}
        	[ -f ${name}.go ]       || GenYamlGo     $inps $outps
        	[ -f ${name}_test.go ]  || GenYamlTestGo $inps $outps
    popd        
}
    		   
#  Generate a skeleton component
GenSkel() {
    module=$1 ; 
    init $*;
    Debug GenSkel $*
    if [ "$3" == "YAML" ]; then 
        GenYamlSkel $*
        return
    fi    
    module=$1;shift
    pkg=$1; 
    FixPkg
    
    if [ $foreign -eq 1 ]; then 
       	return
    fi  
    
    pkg=$newPkg
    Debug GenSkel/FixPkg pfx=$pfx dn=$dn module=$module
    config=$2;  # NONE, TOML, YAML, other later maybe
    name=$3
    shift 3
    SetTypesArgs $*
    Debug GenSkel: name=$name
    return
    
    Debug GenSkel/ERROR: $*
    Debug GenSkel-$version: $module $pkg config=$config input=$inp output=$outp NULLIT=$NULLIT PARAMS: $* 
    shift 5; Debug ARG/VAL: $*
    [ -z $module ] 	&& Fail Missing module
    [ -z $pkg ] 	&& Fail Missing package 
    [ -z $name ] 	&& Fail Missing name 
    mdl=$module
    [ "$module" == "$pkg" ] && mdl=".";  Debug mdl=$mdl pkg=$pkg
    [ -d $src/$mdl/$pkg ]       		 \
        	|| mkdir -p $src/$mdl/$pkg    \
        	|| Die Cannot create $src/$mdl/$pkg.
    src2=$src/$mdl/$pkg

    pushd $src/$module
        	Debug GenSkel/GenConfig.go `pwd`

       	 	[ -f config.go ] || genConfigGO

     
    pushd $src2 || Die Cannot cd  $src2
        Debug GenSkel/subdir `pwd`
        cfg_file="$src/$module/${module}.yamlx" 
        inps=$inp;outps=$outp
        	makePkg2
        	Debug GenSkel/subdir2: `pwd` name: $name $inps $outps
        	[ -f ${name}.go ]       || GenGo     $inps $outps
        	[ -f "${name}_test".go ]  || GenTestGo "$inps" "$outps"
    popd        
}


CheckOut() {
        go get github.com/tyoung3/dummy_repository 
}

case $1 in  
        gs|skel)shift;GenSkel "$@";;
        v)      echo "$pgm-v$version";;
        x)  $EDITOR "${pgm}"  &;;
        *)  cat <<- EOFX
        
        $0-v$version USAGE:  
                gs MODULE PACKAGE CONFIG_TYPE INPORTS OUTPORTS COMPNAME [ARG VAL]...  . Generate skeleton components
                COMPNAME must begin with an upper case letter
                PKG and/or MODULE directories will be created if missing.
                CONFIG_TYPE can be NONE,TOML, or YAML
                v          . Display version
                x          . Edit $pgm
               --help      . Display this usage
                
                Example: $pgm gs ExMod pkg1  YAML 2 3 Func1 Func2 ... 
                
EOFX
        ;;
esac 
            
#################   END OF SCRIPT   ###################         
