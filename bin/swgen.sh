#!/bin/bash

function Debug() {
        [ "$DEBUG" == "Y" ] && echo -e "${yellow}$pgm/DEBUG: $* $reset" 
} 

init() {
    #pgm=swgen_none.sh
    fmt=""
    pgm=$(basename "$0")
    version="0.2.1"
    # HTML=fbpgo.html
    export modpath="$GOPATH/src"

             black="\u001b[30m"
               red="\u001b[31m"
             green="\u001b[32m"
            yellow="\u001b[33m"
              blue="\u001b[34m"
           magenta="\u001b[35m"
              cyan="\u001b[36m"
             white="\u001b[37m"
             reset="\u001b[0m"   
        lightgreen="\u001b[32;1m"

    Debug INIT: Running "$pgm-v$version w/DEBUG.  Args: $* "
    src=/usr/local/src
    [ -d $src ] || Die Cannot find directory $src

    lb='{'
    rb='}'
    for="for"
}


      
Die() {
                echo -e "$red$pgm/DIE: $* $reset"
                exit 1
}

FAIL() { 
	echo "$0/FAIL: $*"
	exit 1
}
	
IdSkel() {
        cat << EOF
        /*  Generated StreamWork component, $name, 
            by $pgm on `date` 
                $inp  input  ports 
                $outp output ports 
        */ 
EOF
}

GenOutP1() {
	Debug GenOutP1
	cat <<- EOF >> "${name}.go" 
	$routine ${pfx}Send(cs[$outp], &_wg2)
EOF

}

GenInP1() {
	cat <<- EOF >> ${name}.go 
	$routine ${pfx}Recv(cs[$inp], &_wg2, arg, $inp)
EOF

}
 
GenOutP() {      
         if [ $outp -eq 1 ]; then 
                cat << EOFX >> ${name}.go       
                
	 // $name: outp=$outp; inp=$inp; po=$po
                        cs[$inp] <- $inp
                        
EOFX
         else   
                
                msg="$pkg/$name $((po-1))"
                cat << EOFX >> ${name}.go
                
                i := $po-1
                
                $for i >= $inp $lb
                        cs[i] <- "$msg" 
                        close(cs[i])
                        i--
                $rb

EOFX
        fi
}

makeYAML() {
	Debug FAIL makeYAML "$@" 
        cat <<- EOF > $1
# $HOME/.sw/${pkg}.yaml
#    generated by swgen.sh `date`
---
global:                 # Options for all components in $pkg
  buffersize: 0         # Integer example.
  seqno: 1237          # Used to check for valid config file.
EOF
        
}

concatYAML() {
        Debug concatYAML $1 at `pwd`
        
        # yamllint <(( echo $module/${pkg}: ))
        cat <<- EOF >> $1
$module/${pkg}:
  bornon: `date -I'seconds'`
  title: "${cyan}Module:$module Pkg:$pkg${reset}"
  seqno: 1234   # Used to check for valid config file.
  buffersize: 1  # Integer example.
EOF
}

genPkgYAML() {  
    Debug genPkgYAML Args: $*
        
    args=" "
    getargs=""

    allargs=($*) 
	i=${#allargs[@]}  
        
    while [ $i -gt 1 ]; do 
        
	arg=${allargs[$(($i-2))]}
        val=${allargs[$(($i-1))]}
        
	Debug i=$i  arg=$arg val=$val
	
	getargs="$arg, _ := cfg.StringOr(\"$module/${pkg}.$arg\", \"$val\")
	$getargs" 
        
	args="fmt.Print(\"; $arg=\",$arg)  
	$args" 
	
	i=$(($i-2))
	
    done
     	
	Debug make args $*
}      
   
makeChnlTypes() {   
    Debug makeChanlTypes types = ${types[*]}
    chnlTypes=""
    dn=0
    
    nt=${#types[*]} ; # Number of array elements
    
    while [ $dn -lt $nt ]; do
	    	chnlTypes="$chnlTypes, _ch$dn chan ${types[$dn]}"
	    	dn=$(($dn+1))
    done
	    	
}   
genTypeCalls(){	 	     
	 	 		 nt=${#types[*]}  
	 	 		 ct=0	
	 	 		  
	 	 		 while [ $ct -lt $nt ]; do
	 	 		   cn=$ct
	 	 		   if [ ${directs[$ct]} == "I" ]; then 
	 	 		 		cat <<- EOF >> $name.go
	 	 		 		go func() { 
	 	 		 		  var _ip$cn ${types[$ct]}
	 	 		 			_ip$cn._Recv (_ch$cn,&_wg2,)
	 	 		 		}()
	 	 		 			
EOF
	 	 		   else   
	 	 		 		cat <<- EOF >> $name.go
	 	 		 		var _ip$cn ${types[$ct]}
	 	 		 		go  func() {
	 	 		 			  _ip$cn._Send(_ch$cn,&_wg2)
	 	 		 	  }()
	 	 		 		  
EOF
	 	 		  fi
	 	 		  ct=$(($ct+1))
	 	 		 done
}	 
	 		 
genGoCalls() {		
	 	 Debug Gen genGoCalls ${types[*]} ${directs[*]}
	 	 if [ true ]; then
	 	     genTypeCalls
	 	 else   # Generate interfacd{} calls
         outp=$nports
         inp=$inps
         while [ $outp -gt $inps ]; do
                outp=$(($outp - 1))
                GenOutP1
         done
         
         while [ $inp -gt  0 ]; do
                inp=$(($inp-1))
                GenInP1
         done
              
     fi
}   

# Generate component code
GenGo() {       
	
    makeChnlTypes
    
    nports=$(($inps + $outps))
    Debug GenGo-a $name $* $config  $inps $outps  $nports $cfg_file
	 
         cat <<- EOF > ${name}.go 
    package $pkg2
                
    `IdSkel` 
                 
    import (
        $fmt
        "sync"
        // ${NULLIT}"github.com/$USER/$module"
    )
             
		// $name is @todo undocumented
    func $name(wg *sync.WaitGroup, arg []string $chnlTypes ){
                
        defer wg.Done()
        Debug("$name running with DEBUG=Y")
        $go_config3
EOF
	    
	 if [ $nports -gt 0 ]; then 
	    cat <<- EOFNP >> ${name}.go
	    var _wg2 sync.WaitGroup
	    _wg2.Add($nports) 

EOFNP
	 fi
	
	 if [ $nports -eq 1 ]; then
	 	routine=""
	 else 
	 	routine="go"
	 fi 
	 	
	 genGoCalls
              
   if [ $nports -gt 0 ]; then 
        	 cat <<- EOF >> ${name}.go 
		 _wg2.Wait() 
}		        	
EOF
	 else 
	 	echo "}" >> ${name}.go
   fi  	 

   gofmt -w -s ${name}.go
}

GenTestOutP() {         
                cat << EOFX >> ${name}_test.go
                
                i := $ni
                $for i >= 0 $lb
                        cs[i] <- i
                        close(cs[i])
                        i--
                $rb
EOFX
}

# Create list of  channels in $channels 
makeTestChannels() {
	
	echo "" >> ${name}_test.go
	channels=""
	cn=0
	for ct in ${types[*]}; do
		channels="$channels, _cs$cn "
		echo "var _cs$cn chan $ct" >> ${name}_test.go
	  cn=$(($cn+1))
	done 
	
}

GenTestGo() {   
         ni=$1
         no=$2
	 Debug GenTestGo $name $ni $no
	 inp=$ni; outp=$no
         cat << EOFY > ${name}_test.go
                package $pkg2

	
        `IdSkel`
        
import "testing"
import "fmt"
import "sync"

func TestSkel_${name}(t *testing.T) {
        var cs  []chan interface{}
        var wg  sync.WaitGroup
        
        arg := []string{"TestSkel_${name}"}
        
        fmt.Println(arg[0])
EOFY
   
    nports=$(($no + $ni))
    if [ $nports -gt 0 ]; then      
                cat << EOFY >> ${name}_test.go  
                $for i :=0; i < $no + $ni; i++ $lb
                        cs = append(cs,make(chan interface{}))
                $rb
EOFY
        fi
        
 				makeTestChannels;  
         cat << EOFY >> ${name}_test.go
        
        wg.Add(2) 
        go func() { 
EOFY

                        # For each input port, receive one ip.
         if [ $no -gt  0 ]; then
                no=$(($no-1))
                po=$(($no+$ni))
                cat << EOFZ >> ${name}_test.go  
 
                j := $po
                $for j >= $ni $lb
                        ip, ok := <- cs[j]
                        if ok != true {
                                break
                        }
                        fmt.Println("chan:",j,"IP:",ip);
                j--
            $rb   
              
EOFZ
         fi
     
     
     if [ $ni -gt 0 ];  then
        ni=$(($ni-1))
                GenTestOutP
         fi
         
         cat << EOFY >> ${name}_test.go
                        fmt.Println("TestSkel_${name} Ended")
                        wg.Done()
                        return
        }() 
        
        go $name(&wg, arg $channels)
        wg.Wait() 
}             
EOFY
        go fmt ${name}_test.go
}

GenYamlGo() {
    Debug GenYamlGo $*
    fmt="\"fmt\""
    go_config='config "github.com/zpatrick/go-config"'      
        go_config2="$fconfig"
        go_config3="cfg := ${pfx}PkgConfig()
    bs, _ := cfg.IntOr(\"$module/${pkg}.buffersize\", 1)
    seqno, _ := cfg.IntOr(\"$module/${pkg}.seqno\", 1)
    title, _ := cfg.StringOr(\"$module/${pkg}.title\", \"n/a\")
    version := \"v0.0.0\"
    
    fmt.Println(title, 
                \"${cyan}gRunning7\", 
                arg[0],\"-\",  
                \"$name\",
                version, 
                \"bs =\", bs, 
                \"seqno = \", seqno,\"$reset\") 
    
    if seqno != 1234 {
        fmt.Println(
          \"$module/${pkg}/$name: Seqno is, seqno, not = 1234.  Missing config file?\")
    } 
    "   
    GenGo $*
    concatYAML $cfg_file
}

GenYamlTestGo() {
    GenTestGo $*
}
         
Fail() {
	echo -e Usage: $pgm gs MODULE PACKAGE CONFIG_TYPE INPORTS OUTPORTS Component [ARG VAL]...
	Die $*
}
        
makePkg2() {
	pkg2=`basename $pkg`
}
 
	# Find ROOT in ROOT/.../... 	
GetRoot() {
	p2=$1
		newPkg="`basename $p2`"
		pkgroot=$p2
		p2="`dirname $pkgroot`"
	while [ "$p2" != "." ]; do 
		pkgroot=$p2
		p2="`dirname $pkgroot`"
	done			
}
  
FixPkg() {
    Debug FixPkg
	dn="`basename $pkg`"  
	[ "$dn" == "$module" ] && pkg="`basename $pkg`" && NULLIT="// " || pfx="${module}."
	
	# Change pkg = $module/..../pkg2 to .../pkg2
        GetRoot $pkg
        Debug FixPkg: pkg=$pkg pkgroot=$pkgroot module=$module
        if [ "$module" != "$pkgroot" ]; then
        	foreign=1;  return
        fi 
        foreign=0	
}
 
createTypes() {
	Debug createTypes ${types[*]}
	for typ in ${types[*]}; do
		 if [ ! -f "${typ}.go" ]; then 
		 	 cat << EOF >	"${typ}.go"
package $module	

import "sync"
import "fmt"

// $typ Generated by swgen.sh  
type $typ struct {
		Id string
		Key string
		Value int
}

// Stringer stringifies $typ structures for functions like fmt.Println
func (_ip $typ) Stringer() string {
	_bfr := fmt.Sprintf("%s:%s:%d", _ip.Id, _ip.Key, _ip.Value) 
	return _bfr
}

// Send emits one $typ IP
func (_ip $typ) _Send( 
	_ci chan $typ, 
	_wg2 *sync.WaitGroup, 
	) {
 	
 		defer _wg2.Done()
 		_ci   <- _ip
}

// Recv receives and prints,  $typ IPs
func (_ip $typ) _Recv( 
	_ci chan $typ, 
	_wg2 *sync.WaitGroup, 
	) {
 	
 	defer _wg2.Done()
 	for {
 		_ip, ok := <- _ci
 		if ok != true {
 				return 
 		}		   
 		fmt.Println(  "Recv $typ/received:", _ip)
 	}
}			
EOF
		   
		 fi
  done		 
}
 
genConfigGO() {       	 	
	Debug genConfigGO
	createTypes
       	cat <<- EOF > config.go
package $module

/* Generated by $pgm-$version */	      	 
import "sync"
import "fmt"
import "os"
  
	 		
type ipT struct {   /* Information Packet type */ 
 	P string   /* Process Name  */
 	S string   /* modulepath/component */
 	I int      /* Port number */
}

const (
	yellow string = "\u001b[33m"
	reset  string = "\u001b[0m"
)

func Debug(s string) {
 	if os.Getenv("DEBUG") == "Y" {
 	 	fmt.Print(yellow)
 	 	fmt.Println("postage/config.go/DEBUG:",s,reset)
 	} 
} 	

	func init() {
		os.Setenv("DEBUG","Y")
	}	
		
	// Send transmits one IP   
	func  Send( ci chan interface{}, _wg2 *sync.WaitGroup, arg []string, nport int ) {
		defer _wg2.Done()
		var ip ipT
		ip.I = nport
		ip.P = arg[0]
		ci   <- ip
	}	
	// Recv receives and reports one IP
	func  Recv( ci chan interface{}, _wg2 *sync.WaitGroup, arg []string, nport int ) {
		defer _wg2.Done()
		ip, _ := <- ci   
		fmt.Println( arg[0], nport,  "received:", ip)
	}						 
EOF
}        
 
tpNotIntypesd() {
	for t in $typesd; do 
		if [ "$t" == "$tp" ]; then 
			dupe="Y"
			return
		fi	
	done 
	typesd="$tp $typesd"
	dupe="N"
} 

GenerateTypesx() {
	Debug GenerateTypes ${types[*]}
	typesd=""
	for tp in ${types[*]}; do 
		Debug GTx: $tp
		tpNotIntypesd
		if [ "$dupe" == "N" ]; then 
		   Debug GT: $tp typesd=$typesd
		   genTypes="type $tp struct {
		   Id string
		   Key string
		   Value int
}

$genTypes"
		fi
	done
	
	Debug GenerateTypes: typesd=$typesd

}
  
SetTypesArgs() {
	Debug SetTypesArgs $*
        typesx=""
        directsx=""
	inps=0; outps=0
	nt=0
	while [ ! -z $1 ]; do
		if [ "$1" == "-i" ]; then 
			directs[$nt]="I";	
			shift 1
			typesx="${typesx}$1 "
			inps=$(($inps+1))
		else if [ "$1" == "-o" ]; then
			directs[$nt]="O";	
			shift 1
			typesx="${typesx}$1 "
			outps=$(($outps+1))
		else
			args=($*)
			shift $#	
		fi 
		fi
		nt=$(($nt+1)) 	    
		shift 1
	done
	
	types=($typesx)
	# directs=${directsx}
}

#  Generate a skeleton component w/YAML   
GenYamlSkel() {
    config=$3
    Debug GenYamlSkel config=$config $*
	module=$1;shift;
        pkg=$1; 
        FixPkg
        if [ $foreign -eq 1 ]; then 
        	return
        fi  
        pkg=$newPkg
	Debug GenYamlSkel/FixPkg pfx=$pfx dn=$dn module=$module
        config=$2;  # NONE, TOML, YAML, other later maybe
        name=$3
        
       shift 3
       SetTypesArgs $*
       Debug GenYamlSkel: name=$name directs=\"$directs\" types=\"${types[*]}\" args=\"${args[*]}\" inps=$inps outps=$outps

       
        cfg_file="$src/$module/${module}.yaml"
      #  Debug GenYamlSkel-$version: $module $pkg config=$config input=$inp output=$outp NULLIT=$NULLIT PARAMS: $* 
        # shift 5; Debug ARG/VAL: $*
        [ -z $module ] 	&& Fail Missing module
        [ -z $pkg ] 	&& Fail Missing package 
        [ -z $name ] 	&& Fail Missing name 
        mdl=$module
        [ "$module" == "$pkg" ] && mdl=".";  Debug mdl=$mdl pkg=$pkg
        [ -d $src/$mdl/$pkg ]       		 \
        	|| mkdir -p $src/$mdl/$pkg    \
        	|| Die Cannot create $src/$mdl/$pkg.
        src2=$src/$mdl/$pkg

    pushd $src/$module
                genPkgYAML   ; # ?? $*
        	Debug GenYamlSkel/GenConfig.go `pwd` genTypes=$genTypes
		createTypes
       	 	[ -f config.go ] ||   \
       	 		cat <<- EOF > config.go
package $module

/* Generated by swgen.sh-v$version */	      	 		
import config "github.com/zpatrick/go-config"
import "sync"
import "fmt"
import "os"  	 		

type ipT struct {   /* Information Packet type */ 
 	P string   /* Process Name  */
  	S string   /* modulepath/component */
 	I int      /* Port number */
}

const (
	yellow string = "\u001b[33m"
	reset  string = "\u001b[0m"
)

func Debug(s string) {
 	if os.Getenv("DEBUG") == "Y" {
 	 	fmt.Print(yellow)
 	 	fmt.Println("postage/config.go/DEBUG:",s,reset)
 	} 
} 	

func init() {
 	os.Setenv("DEBUG","Y")
}
 				
// PkgConfig initializes the go-config package.  See: https://github.com/zpatrick/go-config for details.
func PkgConfig()  *config.Config {
        mappings := map[string]string{
                "${pkg^^}_BUFFERSIZE": "${pkg}.buffersize",
                "SEQNO":      "seqno=7",
        }
        
        return config.NewConfig([]config.Provider  {
                config.New${config}File("$src/$pkg/${module}.yaml"), 
                config.NewEnvironment(mappings)} )      
}

	// Send transmits one IP   
func  Send( ci chan interface{}, _wg2 *sync.WaitGroup, arg []string, nport int ) {
 	defer _wg2.Done()
 	var ip ipT
 	ip.I = nport
 	ip.P = arg[0]
 	ci   <- ip
}

	// Recv receives and reports one IP
func  Recv( ci chan interface{}, _wg2 *sync.WaitGroup, arg []string, nport int ) {
 	defer _wg2.Done()
 	ip, _ := <- ci   
 	fmt.Println( arg[0], nport,  "received:", ip)
}						 
EOF


    pushd $src2 || Die Cannot cd  $src2
        Debug GenYamlSkel/subdir `pwd`
        cfg_file="$src/$module/${module}.yaml" 
        [ -f $cfg_file ] || makeYAML $cfg_file
        # inps=$inp;outps=$outp
        	makePkg2
        	Debug `pwd` name: $name $inps $outps ${types[*]}
        	[ -f ${name}.go ]       || GenYamlGo     $inps $outps
        	[ -f ${name}_test.go ]  || GenYamlTestGo $inps $outps
    popd        
}
    		   
#  Generate a skeleton component
GenSkel() {
    module=$1 ; 
    init $*;
    Debug GenSkel $*
    if [ "$3" == "YAML" ]; then 
        GenYamlSkel $*
        return
    fi    
    module=$1;shift
    pkg=$1; 
    FixPkg
    
    if [ $foreign -eq 1 ]; then 
       	return
    fi  
    
    pkg=$newPkg
    Debug GenSkel/FixPkg pfx=$pfx dn=$dn module=$module
    config=$2;  # NONE, TOML, YAML, other later maybe
    name=$3
    shift 3
    SetTypesArgs $*
    Debug GenSkel: name=$name
    return
    
    Debug GenSkel/ERROR: $*
    Debug GenSkel-$version: $module $pkg config=$config input=$inp output=$outp NULLIT=$NULLIT PARAMS: $* 
    shift 5; Debug ARG/VAL: $*
    [ -z $module ] 	&& Fail Missing module
    [ -z $pkg ] 	&& Fail Missing package 
    [ -z $name ] 	&& Fail Missing name 
    mdl=$module
    [ "$module" == "$pkg" ] && mdl=".";  Debug mdl=$mdl pkg=$pkg
    [ -d $src/$mdl/$pkg ]       		 \
        	|| mkdir -p $src/$mdl/$pkg    \
        	|| Die Cannot create $src/$mdl/$pkg.
    src2=$src/$mdl/$pkg

    pushd $src/$module
        	Debug GenSkel/GenConfig.go `pwd`

       	 	[ -f config.go ] || genConfigGO

     
    pushd $src2 || Die Cannot cd  $src2
        Debug GenSkel/subdir `pwd`
        cfg_file="$src/$module/${module}.yamlx" 
        inps=$inp;outps=$outp
        	makePkg2
        	Debug GenSkel/subdir2: `pwd` name: $name $inps $outps
        	[ -f ${name}.go ]       || GenGo     $inps $outps
        	[ -f ${name}_test.go ]  || GenTestGo $inps $outps
    popd        
}


CheckOut() {
        go get github.com/tyoung3/dummy_repository 
}

case $1 in  
        gs|skel)shift;GenSkel $*;;
        v)      echo $pgm-v$version;;
        x)  $EDITOR ${pgm}  &;;
        *)  cat <<- EOFX
        
        $0-v$version USAGE:  
                gs MODULE PACKAGE CONFIG_TYPE INPORTS OUTPORTS COMPNAME [ARG VAL]...  . Generate skeleton components
                COMPNAME must begin with an upper case letter
                PKG and/or MODULE directories will be created if missing.
                CONFIG_TYPE can be NONE,TOML, or YAML
                v          . Display version
                x          . Edit $pgm
               --help      . Display this usage
                
                Example: $pgm gs ExMod pkg1  YAML 2 3 Func1 Func2 ... 
                
EOFX
        ;;
esac 
            
#################   END OF SCRIPT   ###################         
