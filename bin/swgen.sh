#!/bin/bash

# SWGEN.sh  Created from SWSKEL.sh from SW.sh
# https://dave.cheney.net/2013/04/30/curious-channels
# https://go101.org/

# Generate/explain init function  ?? todo 

pgm=swgen.sh
version="0.3.2"
HTML=fbpgo.html

             black="\u001b[30m"
               red="\u001b[31m"
             green="\u001b[32m"
            yellow="\u001b[33m"
              blue="\u001b[34m"
           magenta="\u001b[35m"
              cyan="\u001b[36m"
             white="\u001b[37m"
             reset="\u001b[0m"   
        lightgreen="\u001b[32;1m"
   
NOTE_BgColors() {
	cat << EOF        
   # NOTE: Go ignores files and directories beginning with '_', as in _OLD/
        Background Black: \u001b[40m
	Background Red: \u001b[41m
	Background Green: \u001b[42m
	Background Yellow: \u001b[43m
	Background Blue: \u001b[44m
	Background Magenta: \u001b[45m
	Background Cyan: \u001b[46m
	Background White: \u001b[47m
EOF
}
        
Die() {
                echo -e "$red$pgm/DIE: $* $reset"
                exit 1
}

Debug() {
        [ "$DEBUG" == "y" ] && echo -e "${yellow}$pgm/DEBUG: $* $reset" 
} 

Debug Running $pgm w/DEBUG.  Args: $*

Verbose() {
        if [ ! -z $verbose ]; then
                echo "${pgm}.sh: $*"
        fi      
} 


# NotesFBP(): See SWSKEL.SH

Notesx() { 
        cat <<- EOF
                Workflow: https://gist.github.com/blackfalcon/8428401
                Code generation from BNF: https://github.com/goccmack/gocc
                Using gocc: https://medium.freecodecamp.org/write-a-compiler-in-go-quick-guide-30d2f33ac6e0
        Tutorial: https://tour.golang.org/welcome/1
        Specification: https://golang.org/ref/spec#Notation
                http://www.cs.sfu.ca/CourseCentral/383/tjd/     syntaxAndEBNF.html#defining-language-syntax-with-extended-backus-naur-form

EOF

}

src=$GOPATH/src/gen

MakeDir2() {
        dir2=$1
        ddate=`date`
        Verbose Making $dir2
        [ -d $dir2 ]            \
        || ( mkdir -p $dir2             \
        && cat << EOF > $dir2/_README.md
        $dir2   generated by ${pgm}.sh-v$version on $ddate       
EOF
        )
}

MakeDir() {
        for dir in $*; do 
                MakeDir2 $dir
        done
}
        

# SeeDocs(): See SWSKEL.SH

IdSkel() {
        cat << EOF
        /*  Generated StreamWork component, $name, 
            by sw.sh on `date` 
                $inp  input  ports 
                $outp output ports 
        */ 
EOF
}

lb='{'
rb='}'
for="for"

GenOutP1() {
	Debug GenOutP1
	cat <<- EOF >> ${name}.go 
	$routine ${module}.Send(cs[$outp], &wg2, arg, $outp)
EOF

}

GenInP1() {
	cat <<- EOF >> ${name}.go 
	$routine ${module}.Recv(cs[$inp], &wg2, arg, $inp)
EOF

}
 
GenOutP() {      
         if [ $outp -eq 1 ]; then 
                cat << EOFX >> ${name}.go       
                
	 // $name: outp=$outp; inp=$inp; po=$po
                        cs[$inp] <- $inp
                        
EOFX
         else   
                
                $msg="$pkg/$name $((po-1))"
                cat << EOFX >> ${name}.go
                
                i := $po-1
                
                $for i >= $inp $lb
                        cs[i] <- "$msg" 
                        close(cs[i])
                        i--
                $rb

EOFX
        fi
}

makeFile() {
        cat <<- EOF > $1
        # $HOME/.sw/${pkg}.toml generated by swskel `date` 
        [$pkg]   # Options for all components in package, $pkg
        seqno=1234    #Used to check for valid config file. 
        buffersize=1  #Integer example. 
        title="${red}StreamWork Example Package${reset}" 
        bornon=`date -I'seconds'
`
        
        # Add additional options here -- e.g.
        [bar]
        title="Foo.bar Example"
EOF
        
}


makeYAML() {
	Debug makeYAML $* 
        cat <<- EOF > $1
# $HOME/.sw/${pkg}.yaml
#    generated by swgen.sh `date`
---
global:                 # Options for all components in $pkg
  buffersize: 0         # Integer example.
  seqno: 1237          # Used to check for valid config file.
EOF
        
}

concatYAML() {
        Debug concatYAML $1 at `pwd`
        
        # yamllint <(( echo $module/${pkg}: ))
        cat <<- EOF >> $1
$module/${pkg}:
  bornon: `date -I'seconds'`
  title: "${cyan}Module:$module Pkg:$pkg${reset}"
  seqno: 1234   # Used to check for valid config file.
  buffersize: 1  # Integer example.
EOF
	
        
}

genPkgConfig() {        fconfig="
/* PkgConfig initializes the go-config package.
See: https://github.com/zpatrick/go-config for details*/
func PkgConfig()  *config.Config {
        mappings := map[string]string{
                \"${pkg^^}_BUFFERSIZE\": \"${pkg}.buffersize\",
        }
        
        return config.NewConfig([]config.Provider  {
                config.New${config}File(\"$src/${module}.yaml\"), 
                config.NewEnvironment(mappings)} )      
}
"           
        go_config='config "github.com/zpatrick/go-config"'      
        go_config2="$fconfig"
        go_config3="cfg := PkgConfig(\"/home/tyoung3/go/src/gen/${module}.toml\")
    bs, _ := cfg.IntOr(\"$module/${pkg}.buffersize\", 1)
    seqno, _ := cfg.IntOr(\"$module/${pkg}.seqno\", 1)
    title, _ := cfg.StringOr(\"$module/${pkg}.title\", \"n/a\")
    version := \"v0.0.0\"
    
    fmt.Println(title, 
                \"${cyan}gRunning7\", 
                arg[0],"-",  
                $name,
                version, 
                \"bs =\", bs, 
                \"seqno = \", seqno,"$reset") 
    
    if seqno != 1234 {
        fmt.Println(
          \"$module/${pkg}/$name: Seqno is", seqno, "not = 1234.  Missing config file?\")
    } 
    "    
}

#    // version, _ := cfg.StringOr(\"$module/${pkg}.version\", \"v0.0.0\")

genPkgYAML() {  
        Debug genPkgYAML Args: $*
        
#  defversion='var version string="v0.0.0"'

args=" "
getargs=""

allargs=($*) 
	i=${#allargs[@]}  
        
    while [ $i -gt 1 ]; do 
        
	arg=${allargs[$(($i-2))]}
        val=${allargs[$(($i-1))]}
        
	Debug i=$i  arg=$arg val=$val
	
	getargs="$arg, _ := cfg.StringOr(\"$module/${pkg}.$arg\", \"$val\")
	$getargs" 
        
	args="fmt.Print(\"; $arg=\",$arg)  
	$args" 
	
	i=$(($i-2))
	
    done
     	
	Debug make args $*

	
fconfig="
/* PkgConfig initializes the go-config package.
See: https://github.com/zpatrick/go-config for details*/
func PkgConfig()  *config.Config {
        mappings := map[string]string{
                \"BUFFERSIZE\": \"buffersize\",
                \"SEQNO\": \"seqno=7\",
        }
        
        return config.NewConfig([]config.Provider  {
                config.New${config}File(\"$cfg_file\"), 
                config.NewEnvironment(mappings)} )      
}
"           
        go_config='config "github.com/zpatrick/go-config"'      
        go_config2="$fconfig"
        go_config3="cfg := ${module}.PkgConfig()
    bs, _ := cfg.IntOr(\"$module/${pkg}.buffersize\", 1)
    seqno, _ := cfg.IntOr(\"$module/${pkg}.seqno\", 1)
    title, _ := cfg.StringOr(\"$module/${pkg}.title\", \"n/a\")
    version := \"v0.0.0\"
        $getargs
    
    fmt.Print(title, 
                \" ${cyan}Running \", 
                arg[0],\"\t\",  
                \"${name}-\",
                version, 
                \" bs=\", bs, 
                \" seqno: \", seqno)
    
    $args
    
    fmt.Println(
    	\"$reset\") 
    
    if seqno != 1234 {
        fmt.Println(
          \"${red}$module/${pkg}/$name: Seqno is", seqno, "not = 1234.  Missing config file?$reset\")
    } 
    "    
}       

noPkgConfig() {  
        Debug noPkgConfig $* $config
        go_config=""     
        go_config2=""
        go_config3="cfg := ${module}.PkgConfig() 
    seqno, _ := cfg.IntOr(\"${pkg}.seqno\", 1)
    bs, _ := cfg.IntOr(\"${pkg}.buffersize\", 1)
        fmt.Println(
                \"Running3\", arg[0], version, \"bs =\", bs)  
        
    if seqno != 1234 {
        fmt.Println(
          \"${red}$module/${pkg}/$name: Seqno is", seqno, "not = 1234.  Missing config file?$reset\")
    } "
}


noPkgYAML() {    
        Debug noPkgYAML $* $config
        go_config=""     
        go_config2=""
        go_config3="cfg := ${module}.PkgConfig() 
    seqno, _ := cfg.IntOr(\"${pkg}.seqno\", 1)
    bs, _ := cfg.IntOr(\"${pkg}.buffersize\", 1)
        fmt.Println(
                \"Running4\", arg[0], version, 
                \"bs =\", bs, 
                \"seqno =\", seqno)  
        
    if seqno != 1234 {
        fmt.Println(
          \"${red$module/${pkg}/$name: Seqno is", seqno, "not = 1234.  Missing config file?$reset\")
    } "
}

GenConfig() {
	case $config in 
                 YAML)
                        Debug GenConfig YAML $cfg_file
                    concatYAML $cfg_file
                    if [ "$module" != "$pkg" ]; then 
                  	  go_config2=""
                    	go_config="\"$module\""
                    fi	
                        ;;
                 *)go_config3="fmt.Println(
                \"Running5\", arg[0])" 
                   ;;   
         esac
}         
        
         
        # See:  https://github.com/zpatrick/go-config
GenGo() {       
	 nports=$(($inps + $outps))
         Debug GenGo $name $* $config  $inps $outps  $nports $cfg_file
         echo "$module/$pkg/${name}:" >> $cfg_file
         # echo "  version: v0.0.1" >> $cfg_file
	 
         cat << EOF > ${name}.go 
                package $pkg2
                
                `IdSkel` 
                 
                import (
                        "fmt"
                       "sync"
                       "$module"
                )
                

            func $name(wg *sync.WaitGroup, arg []string, cs []chan interface{} ){
                
                defer wg.Done()
                $go_config3
EOF
	    
	 if [ $nports -gt 0 ]; then 
	    cat <<- EOFNP >> ${name}.go
	    var wg2 sync.WaitGroup
	    wg2.Add($nports) 

EOFNP
	 fi
	
	 if [ $nports -eq 1 ]; then
	 	routine=""
	 else 
	 	routine="go"
	 fi 
	 	
         outp=$nports
         inp=$inps
         while [ $outp -gt $inps ]; do
                outp=$(($outp - 1))
                GenOutP1
         done
         
         while [ $inp -gt  0 ]; do
                inp=$(($inp-1))
                GenInP1
         done
              
              
         if [ $nports -gt 0 ]; then 
        	 cat <<- EOF >> ${name}.go 
		 wg2.Wait()
           	 }
EOF
         fi  	 

        gofmt -w -s ${name}.go
        Debug $EDITOR $cfg_file
	GenConfig
}

GenTestOutP() {         
                cat << EOFX >> ${name}_test.go
                
                i := $ni
                $for i >= 0 $lb
                        cs[i] <- i
                        close(cs[i])
                        i--
                $rb
EOFX
}

GenTestGo() {   
         ni=$1
         no=$2
	 Debug GenTestGo $name $ni $no
	 inp=$ni; outp=$no
         cat << EOFY > ${name}_test.go
                package $pkg2

	
        `IdSkel`
        
import "testing"
import "fmt"
import "sync"

func TestSkel_${name}(t *testing.T) {
        var cs  []chan interface{}
        var wg  sync.WaitGroup
        
        arg := []string{"TestSkel_${name}"}
        
        fmt.Println(arg[0])
EOFY
   
    nports=$(($no + $ni))
    if [ $nports -gt 0 ]; then      
                cat << EOFY >> ${name}_test.go  
                $for i :=0; i < $no + $ni; i++ $lb
                        cs = append(cs,make(chan interface{}))
                $rb
EOFY
        fi
        
         cat << EOFY >> ${name}_test.go
        
        wg.Add(2) 
        go func() { 
EOFY
                        # For each input port, receive one ip.
         if [ $no -gt  0 ]; then
                no=$(($no-1))
                po=$(($no+$ni))
                cat << EOFZ >> ${name}_test.go  
 
                j := $po
                $for j >= $ni $lb
                        ip, ok := <- cs[j]
                        if ok != true {
                                break
                        }
                        fmt.Println("chan:",j,"IP:",ip);
                j--
            $rb   
              
EOFZ
         fi
     
     if [ $ni -gt 0 ];  then
        ni=$(($ni-1))
        #echo ni=$ni
                GenTestOutP
         fi
         
         cat << EOFY >> ${name}_test.go
                        fmt.Println("TestSkel_${name} Ended")
                        wg.Done()
                        return
        }() 
        
        go $name(&wg, arg,  cs)
        wg.Wait()       

}
        
EOFY
	#go mod init $pkg 
        go fmt ${name}_test.go
}
        
Fail() {
	echo -e Usage: $pgm gs MODULE PACKAGE CONFIG_TYPE INPORTS OUTPORTS Component [ARG VAL]...
	Die $*
}
        
makePkg2() {
	pkg2=`basename $pkg`
}
        
        
#  Generate a skeleton component
GenSkel() {
	module=$1;shift;
        pkg=$1; 
        config=$2;  # NONE, TOML, YAML, other later maybe
        inp=$3
        outp=$4
        name=$5
        [ -z $inp ] && inp=0
        [ -z $outp ] && outp=0
        cfg_file="$src/$module/${module}.yaml"
        Debug GenSkel: $module $pkg config=$config input=$inp output=$outp $*
        shift 5; Debug ARG/VAL: $*
        [ -z $module ] 	&& Fail Missing module
        [ -z $pkg ] 	&& Fail Missing package 
        [ -z $name ] 	&& Fail Missing name 
        mdl=$module
        [ "$module" == "$pkg" ] && mdl=".";  Debug mdl=$mdl pkg=$pkg
        [ -d $src/$mdl/$pkg ]       		 \
        	|| mkdir -p $src/$mdl/$pkg    \
        	|| Die Cannot create $src/$mdl/$pkg.
        src2=$src/$mdl/$pkg

    pushd $src/$module
                genPkgYAML   ; # ?? $*
        	Debug GenSkel/GenConfig.go `pwd`

       	 	[ -f config.go ] ||   \
       	 		cat <<- EOF > config.go
package $module
	      	 		
import config "github.com/zpatrick/go-config"
import "sync"
import "fmt"
       	 		
type ip_t struct {   /* Information Packet type */ 
	P string   /* Process Name  */
	S string   /* modulepath/component */
	I int      /* Port number */
}
			
	$fconfig	
	   
	func  Send( ci chan interface{}, wg2 *sync.WaitGroup, arg []string, nport int ) {
		defer wg2.Done()
		var ip ip_t
		ip.I = nport
		ip.P = arg[0]
		ci   <- ip
	}	
	
	func  Recv( ci chan interface{}, wg2 *sync.WaitGroup, arg []string, nport int ) {
		defer wg2.Done()
		ip, _ := <- ci   
		fmt.Println( arg[0], nport,  "received:", ip)
	}						 
EOF

    popd

    pushd $src2 || Die Cannot cd  $src2
        Debug GenSkel/subdir `pwd`
        cfg_file="$src/$module/${module}.yaml" 
        [ -f $cfg_file ] || makeYAML $cfg_file
        inps=$inp;outps=$outp
        	makePkg2
        	Debug `pwd` name: $name $inps $outps
        	[ -f ${name}.go ]       || GenGo     $inps $outps
        	[ -f ${name}_test.go ]  || GenTestGo $inps $outps
        Debug Generate go.mod at $src/$mdl
        [ -f $src/$module/go.mod ] || (pushd $src/$module && go mod init $module && popd) 
        go test -v ./...; # && $EDITOR ${name}_test.go ${name}.go
    popd        
}


CheckOut() {
        go get github.com/tyoung3/dummy_repository 
}

pgm=`basename $0`
case  $pgm in 
        swskel|skel)GenSkel $* && exit 0 || Die $* failed.;;
esac
        
case $1 in      
        gs|skel)shift;GenSkel $*;;
        v)      echo $pgm-v$version;;
        x)  $EDITOR ${pgm}  &;;
        *)  cat <<- EOFX
        
        $0-v$version USAGE:  
                gs MODULE PACKAGE CONFIG_TYPE INPORTS OUTPORTS COMPNAME [ARG VAL]...  . Generate skeleton components
                                        COMPNAME must begin with an upper case letter
                                        PKG and/or MODULE directories will be created if missing.
                                        CONFIG_TYPE can be NONE,TOML, or YAML
                v                       					. Display version
                x                       					. Edit $pgm
               --help                  						. Display this usage
                
                Example: $pgm gs ExMod pkg1  YAML 2 3 Func1 Func2 ... 
                
EOFX
#  Removed 7/23/2020            r                       . Run fbpgo.go
        ;;

esac    
            
#################   END OF SCRIPT   ###################         


