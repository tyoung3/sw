#!/bin/bash

# p.sh:
#	Purpose:  Generate a Streamwork skeleton project 
#
#   Create GO/FBP project(s) from .SW file(s).   
#   Create directory(if not existing) and skeleton files, 
#     generate and test example code, and run the example.   
#   Project sub-directories are created in the current directory.
#   
#   Example:
#	$ ./p.sh g test/X
#

        black="\u001b[30m"
        red="\u001b[31m"
        green="\u001b[32m"	
        lightgreen="\u001b[32;1m"	 
        yellow="\u001b[33m"
        blue="\u001b[34m"
        magenta="\u001b[35m"
        cyan="\u001b[36m"
        white="\u001b[37m"
        reset="\u001b[0m"
        
# @@TODO:  List of banned Modules.   Push Data to file, then have script read file. 
#    git branch to PS1
#    all packages import project code.

pgm=p.sh

Die() {
	echo -e "${red}$self/DIE: $*$reset"
	exit 1
}

Debug() {
        [ "$DEBUG" == "y" ] && echo -e "$yellow$pgm/DEBUG: $* $reset " 
        # echo -e $red Debug $* $reset
        echo -n 
}


#pat  is github Personal Access Token: "SW Project Generation"
pat=c7587f442e2bb2a7784dfa776dc949693aa43ed7 

self=p.sh
version="0.0.1"  
[ -z $GOPATH ] && Die GOPATH is not set
dir=$GOPATH/mod/

Debug Running ${pgm}-$version w/DEBUG args: $*

Display() {
	Debug $*
}

[ -d $dir ] || Die Missing directory: $dir

Init() {
	pushd $dir || Die Cannot pushd $dir
}	

GenCFG() {
	echo #  Project $p  SW.CFG file.Generated by $0 `date` 
	#       
	cat <<- EOF 
	StreamWork:
  defaults:  
    DefaultSourceComp: 	"Gen"
    DefaultSinkComp: 	"Prt"
    DefaultPath: 	"def"
    DefaultFilterComp: 	"Pass"  
    DefaultBufferSize: 	  0    #default GO buffersize
    HTMLdir:	"/home/tyoung3/go/mod/sw/html/" #Where tooltips live
    DefaultLibrary: "$p"
  limits:
    Maxbfsz:   	10000    #Maximum GO buffer size
  SymbolTable:
    Tablesize:	4000     
	
EOF
}

GenGo() {
	 module=$p
	 Debug GenGo:  $*  module=$module
	 /home/tyoung3/go/mod/sw/bin/sw -m 5 ${p}.sw > ./gen_$p.sh 	 
	 chmod a+x ./gen_$p.sh 				 
	 ./gen_$p.sh
	 		 
}    


Genp() {
	Display $GENPy: $*
	pn=$1
	p=`basename $pn`
	sw=${pn}.sw 
	Debug sw=$sw pn=$pn
	[ -f $sw ] || Die Genp: Missing $sw 
	shift 1 
	echo; Display Generating  go module $p  from $sw 
	[ -d $dir/$p ] && echo Updating go module $p  from $sw || echo Display Generating  go module $p  from $sw 
	[ -d $dir/$p ] || mkdir $dir/$p || Die Cannot mkdir $dir/$p
	tdir=$GOPATH/mod/sw/project
	pushd $dir/$p							\
	   && ( [ -d internal ] || mkdir $* internal )			\
	   && ( [ -f go.mod ]  || go mod init $p )			\
	   && pushd internal || Die Cannot pushd internal		\
	   	 && [ -f ${p}.sw ] || cp  $sw ${p}.sw			\
	   	 && GenCFG  > sw.cfg					\
	   	 && Debug internal run sw ${p}.sw			\
	   	 && sw ${p}.sw > ${p}.go				\
	   	 && GenGo $* 						\
	   	 && swgraph ${p}.sw 					\
	   	 && wait						\
	   && popd							\
	   && echo -e "${green}$self: Create project from $sw: Success!$reset" 		\
	   || Die "${red}$self: Create project from $sw: FAILED.$reset"	\
	   && go run internal/${p}.go					\
	   && (pushd internal; go build *.go; popd)			 
	   go fmt  ./...
	   go test ./...
	echo
				 
}

GenProjectP() {
	[ -z $1 ] && Die Missing Module.sw
	Display GenProject for $*		 
	Genp $* 
}

GenProject() {
	[ -z $1 ] && ( Genp X Y ; exit 0 )  	\
	|| Display GenProject for $*		\
	, Genp $* 
}

KillEm() {
	for p in $*; do
		echo Kill $p
	done

}

case $1 in
	p)shift; Die option p OBSOLETE;;  # GenProject $*
	g)shift; GenProjectP $*;;
	k)shift; Init; KillEm $*;;
	l)shift; Init; tree --noreport  -L 2 $*;;
	x)shift; $EDITOR $self;;
	*)cat <<- EOF 

	Usage: $self 
	 	g [PROJECT ...]	. Generate project(s) from PROJECT.sw 
	 	k [JOB...]	. Kill [JOB](s)
	 	l [PROJECT ...] . List PROJECT(s)	
	 	x Edit this script
	 	* Display this help

EOF
	;;
esac
