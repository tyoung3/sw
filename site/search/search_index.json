{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to StreamWork! StreamWork is a simple, flow based, system for creating complex Go programs from components. sw generates a Go main program to create the channels and launch the component processes(go routines) as described in a network definition file.","title":"Home"},{"location":"#welcome-to-streamwork","text":"StreamWork is a simple, flow based, system for creating complex Go programs from components. sw generates a Go main program to create the channels and launch the component processes(go routines) as described in a network definition file.","title":"Welcome to StreamWork!"},{"location":"APIs/","text":"API Comments APIs APIs are typically implemented via function calls, as stated in altexsoft . We suggest most APIs would be better implemented by FBP. Seven API challenges Everything an API The discovery, access, interface, and format of APIs are not standardized leading to fragmentation of programming languages, frameworks and developer consumption models such as containers and serverless as a way to deal with complexity. An existing functional API can be incorporated into a FBP component which interacts via one or more structures. The component can thus simplify and tailor the functional API rules into a more standard API information packet. When several, diverse functional APIs are required to carry out a particular operation, it may be possible to subnet the whole thing into one FBP process with a standard interface. Functional APIs, particulary web-based APIs with their inherent delays, would benefit immediately from FBP's inherent concurrency. API Refenences API2Cart How developers use CMU paper Martin papers Springer PDF arxif PDF API Challenges Patient Access Microservices problem Temporal Project","title":"API Comments"},{"location":"APIs/#api-comments","text":"","title":"API Comments"},{"location":"APIs/#apis","text":"APIs are typically implemented via function calls, as stated in altexsoft . We suggest most APIs would be better implemented by FBP. Seven API challenges Everything an API The discovery, access, interface, and format of APIs are not standardized leading to fragmentation of programming languages, frameworks and developer consumption models such as containers and serverless as a way to deal with complexity. An existing functional API can be incorporated into a FBP component which interacts via one or more structures. The component can thus simplify and tailor the functional API rules into a more standard API information packet. When several, diverse functional APIs are required to carry out a particular operation, it may be possible to subnet the whole thing into one FBP process with a standard interface. Functional APIs, particulary web-based APIs with their inherent delays, would benefit immediately from FBP's inherent concurrency.","title":"APIs"},{"location":"APIs/#api-refenences","text":"API2Cart How developers use CMU paper Martin papers Springer PDF arxif PDF API Challenges Patient Access Microservices problem Temporal Project","title":"API Refenences"},{"location":"DOCKER/","text":"SWGEN Docker Purpose Building Run 'sw.sh d [OPT]' to download and build the Streamwork docker image, sw, where OPT are options for sw.sh within the image. Run sw.sh d --help to get sw.sh help. DISCLAIMER: Building and using StreamWork docker images is untested and comes with no guarantees.","title":"Docker"},{"location":"DOCKER/#swgen-docker","text":"","title":"SWGEN Docker"},{"location":"DOCKER/#purpose","text":"","title":"Purpose"},{"location":"DOCKER/#building","text":"Run 'sw.sh d [OPT]' to download and build the Streamwork docker image, sw, where OPT are options for sw.sh within the image. Run sw.sh d --help to get sw.sh help. DISCLAIMER: Building and using StreamWork docker images is untested and comes with no guarantees.","title":"Building"},{"location":"FBP/","text":"Flow Based Programming StreamWork and 'Classical FBP' We believe StreamWork is consistent with 'Classical Flow Based Programming'. Wikipedia Definition of FBP \"In computer programming, flow-based programming (FBP) is a programming paradigm that defines applications as networks of \"black box\" processes, which exchange data across predefined connections by message passing, where the connections are specified externally to the processes. These black box processes can be reconnected endlessly to form different applications without having to be changed internally. FBP is thus naturally component-oriented. FBP is a particular form of dataflow programming based on bounded buffers, information packets with defined lifetimes, named ports, and separate definition of connections.\" --- Flow Based Programming -- Wikipedia So to summarize, the Wikipedia definition of FBP is charactarized by: Black box processes Separate connection definitions Message(information packet, IP) passing Bounded buffers IPs with defined lifetimes Named Ports Wikipedia does not mention concurrency -- in error, we maintain. Wikipedia also does not mention subnets, data ownership, back pressure, data ownership, or bracketed IPs. StreamWork does not directly implement these features, but there is no obvious reason why these features could not be implemented within the components. StreamWork considers subnets to be an essential design tool, allowing unlimited numbers of subnets and components and a ridiculously large(100) number of subnet levels. Note that StreamWork is highly concurrent and allows for high degrees of parallelism. We claim here that StreamWork meets all the Wikipedia criteria and therefore StreamWork implements 'classical' FBP. StreamWork, however, does not directly incorporate IP defined lifetimes or require specific create/copy/destroy operations. In StreamWork, IPs live only from the moment of sending to the GO channel by the source process until received by the sink process. For buffersizes greater than zero, the GO language allows data even in closed channels to be reaccessed, so for utmost security, zero sized buffers and encryption are recommended for sensitive data, like passwords. Component behavior can be controlled via arguments, environment variables, in-stream commands, ordinary IPs, and signals. StreamWork does not distinguish between IIPs (initialization information packets) and ordinary IPs and therefore does not require any special processin or notation for IIPs within the network definition language. FBP tenets https://jpaulm.github.io/fbp If work is boring, let a robot do it! Corollary: using a design tool should be fun! No one language should try to do everything! The world is asynchronous - don't try to force the systems we build into a synchronous framework! The von Neumann paradigm is only appropriate within a single process! Duh! Any language or system that \"talks data\" should be able to talk to any other one that \"talks data\". A process needs to be able to have more than one input port, and needs to be able to choose which one to receive from! If a process's upstream connection fills up, the process feeding it will be suspended (unless the connection is marked \"DropOldest\") (\"back pressure\") Flow Based Programming References J Paul Morrison Other FBP Projects SpreadSheet Flow Based Programming (Wiki)","title":"FBP"},{"location":"FBP/#flow-based-programming","text":"","title":"Flow Based Programming"},{"location":"FBP/#streamwork-and-classical-fbp","text":"We believe StreamWork is consistent with 'Classical Flow Based Programming'.","title":"StreamWork and 'Classical FBP'"},{"location":"FBP/#wikipedia-definition-of-fbp","text":"\"In computer programming, flow-based programming (FBP) is a programming paradigm that defines applications as networks of \"black box\" processes, which exchange data across predefined connections by message passing, where the connections are specified externally to the processes. These black box processes can be reconnected endlessly to form different applications without having to be changed internally. FBP is thus naturally component-oriented. FBP is a particular form of dataflow programming based on bounded buffers, information packets with defined lifetimes, named ports, and separate definition of connections.\" --- Flow Based Programming -- Wikipedia So to summarize, the Wikipedia definition of FBP is charactarized by: Black box processes Separate connection definitions Message(information packet, IP) passing Bounded buffers IPs with defined lifetimes Named Ports Wikipedia does not mention concurrency -- in error, we maintain. Wikipedia also does not mention subnets, data ownership, back pressure, data ownership, or bracketed IPs. StreamWork does not directly implement these features, but there is no obvious reason why these features could not be implemented within the components. StreamWork considers subnets to be an essential design tool, allowing unlimited numbers of subnets and components and a ridiculously large(100) number of subnet levels. Note that StreamWork is highly concurrent and allows for high degrees of parallelism. We claim here that StreamWork meets all the Wikipedia criteria and therefore StreamWork implements 'classical' FBP. StreamWork, however, does not directly incorporate IP defined lifetimes or require specific create/copy/destroy operations. In StreamWork, IPs live only from the moment of sending to the GO channel by the source process until received by the sink process. For buffersizes greater than zero, the GO language allows data even in closed channels to be reaccessed, so for utmost security, zero sized buffers and encryption are recommended for sensitive data, like passwords. Component behavior can be controlled via arguments, environment variables, in-stream commands, ordinary IPs, and signals. StreamWork does not distinguish between IIPs (initialization information packets) and ordinary IPs and therefore does not require any special processin or notation for IIPs within the network definition language.","title":"Wikipedia Definition of FBP"},{"location":"FBP/#fbp-tenets-httpsjpaulmgithubiofbp","text":"If work is boring, let a robot do it! Corollary: using a design tool should be fun! No one language should try to do everything! The world is asynchronous - don't try to force the systems we build into a synchronous framework! The von Neumann paradigm is only appropriate within a single process! Duh! Any language or system that \"talks data\" should be able to talk to any other one that \"talks data\". A process needs to be able to have more than one input port, and needs to be able to choose which one to receive from! If a process's upstream connection fills up, the process feeding it will be suspended (unless the connection is marked \"DropOldest\") (\"back pressure\")","title":"FBP tenets https://jpaulm.github.io/fbp"},{"location":"FBP/#flow-based-programming-references","text":"J Paul Morrison Other FBP Projects SpreadSheet Flow Based Programming (Wiki)","title":"Flow Based Programming References"},{"location":"PROJECT/","text":"Copyright (C) 2019,2020 Thomas W. Young, streamwork@twyoung.com Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file or its derivitaves except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Generate a Project Description Generate project files from a network definition file. Build and run the executable. QuickStart (on Linux) Install go Install sw: go get github.com/tyoung3/sw Change sw.cfg to fit your environment. Run sw.sh c go build and make sw (if necessary). Example sw.sh p project/test/X Y Z OUTPUT: Generated module at $GOPATH/mod with packages and component stubs for all components referenced in the network definition file(X.SW file). X \u2502 \u251c\u2500\u2500 sw.tmpl \u2502 \u251c\u2500\u2500 X \u2502 \u251c\u2500\u2500 X.go \u2502 \u2514\u2500\u2500 X.sw \u251c\u2500\u2500 X.yaml \u251c\u2500\u2500 Y \u2502 \u251c\u2500\u2500 Comp1.go \u2502 \u251c\u2500\u2500 Comp1_test.go \u2502 \u251c\u2500\u2500 Comp2.go \u2502 \u251c\u2500\u2500 Comp2_test.go \u2502 \u251c\u2500\u2500 Comp3.go \u2502 \u2514\u2500\u2500 Comp3_test.go \u2514\u2500\u2500 Z \u251c\u2500\u2500 Comp1.go \u251c\u2500\u2500 Comp1_test.go \u251c\u2500\u2500 Comp2.go \u251c\u2500\u2500 Comp2_test.go \u251c\u2500\u2500 Comp3.go \u2514\u2500\u2500 Comp3_test.go Executable program at X/X (package main) EXECUTABLE OUTPUT: Module:X Pkg:Z Running C - Comp3 v0.0.0 bs = 1 seqno: 1234 Module:X Pkg:Y Running A - Comp1 v0.0.0 bs = 1 seqno: 1234 C chan: 1 IP: 38 Module:X Pkg:Z Running B - Comp2 v0.0.0 bs = 1 seqno: 1234 B chan: 0 IP: 37 C chan: 0 IP: 1 Environment Variables DEBUG y)issue yellow debug messages n) No debug messages. Add a component/package to a module: swgen.sh gs MODULE PACKAGE CONFIG_TYPE INPORTS OUTPORTS COMPNAME [ARG VAL]... Ex. swgen.sh gs X pkg_a YAML 2 3 a_Comp4 arg1 var1 Output: X \u251c\u2500\u2500 config.go \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 internal \u2502 \u251c\u2500\u2500 sw.cfg \u2502 \u251c\u2500\u2500 sw.tmpl \u2502 \u251c\u2500\u2500 X \u2502 \u251c\u2500\u2500 X.go \u2502 \u2514\u2500\u2500 X.sw \u251c\u2500\u2500 pkg_a \u2502 \u251c\u2500\u2500 a_Comp4.go \u2502 \u2514\u2500\u2500 a_Comp4_test.go \u251c\u2500\u2500 X.yaml \u251c\u2500\u2500 Y \u2502 \u251c\u2500\u2500 Comp1.go \u2502 \u251c\u2500\u2500 Comp1_test.go \u2502 \u251c\u2500\u2500 Comp2.go \u2502 \u251c\u2500\u2500 Comp2_test.go \u2502 \u251c\u2500\u2500 Comp3.go \u2502 \u2514\u2500\u2500 Comp3_test.go \u2514\u2500\u2500 Z \u251c\u2500\u2500 Comp1.go \u251c\u2500\u2500 Comp1_test.go \u251c\u2500\u2500 Comp2.go \u251c\u2500\u2500 Comp2_test.go \u251c\u2500\u2500 Comp3.go \u2514\u2500\u2500 Comp3_test.go 4 directories, 23 files","title":"Project Generation"},{"location":"PROJECT/#generate-a-project","text":"","title":"Generate a Project"},{"location":"PROJECT/#description","text":"Generate project files from a network definition file. Build and run the executable.","title":"Description"},{"location":"PROJECT/#quickstart-on-linux","text":"Install go Install sw: go get github.com/tyoung3/sw Change sw.cfg to fit your environment. Run sw.sh c go build and make sw (if necessary).","title":"QuickStart (on Linux)"},{"location":"PROJECT/#example","text":"sw.sh p project/test/X Y Z","title":"Example"},{"location":"PROJECT/#output","text":"Generated module at $GOPATH/mod with packages and component stubs for all components referenced in the network definition file(X.SW file). X \u2502 \u251c\u2500\u2500 sw.tmpl \u2502 \u251c\u2500\u2500 X \u2502 \u251c\u2500\u2500 X.go \u2502 \u2514\u2500\u2500 X.sw \u251c\u2500\u2500 X.yaml \u251c\u2500\u2500 Y \u2502 \u251c\u2500\u2500 Comp1.go \u2502 \u251c\u2500\u2500 Comp1_test.go \u2502 \u251c\u2500\u2500 Comp2.go \u2502 \u251c\u2500\u2500 Comp2_test.go \u2502 \u251c\u2500\u2500 Comp3.go \u2502 \u2514\u2500\u2500 Comp3_test.go \u2514\u2500\u2500 Z \u251c\u2500\u2500 Comp1.go \u251c\u2500\u2500 Comp1_test.go \u251c\u2500\u2500 Comp2.go \u251c\u2500\u2500 Comp2_test.go \u251c\u2500\u2500 Comp3.go \u2514\u2500\u2500 Comp3_test.go Executable program at X/X (package main)","title":"OUTPUT:"},{"location":"PROJECT/#executable-output","text":"Module:X Pkg:Z Running C - Comp3 v0.0.0 bs = 1 seqno: 1234 Module:X Pkg:Y Running A - Comp1 v0.0.0 bs = 1 seqno: 1234 C chan: 1 IP: 38 Module:X Pkg:Z Running B - Comp2 v0.0.0 bs = 1 seqno: 1234 B chan: 0 IP: 37 C chan: 0 IP: 1","title":"EXECUTABLE OUTPUT:"},{"location":"PROJECT/#environment-variables","text":"DEBUG y)issue yellow debug messages n) No debug messages.","title":"Environment Variables"},{"location":"PROJECT/#add-a-componentpackage-to-a-module","text":"swgen.sh gs MODULE PACKAGE CONFIG_TYPE INPORTS OUTPORTS COMPNAME [ARG VAL]... Ex. swgen.sh gs X pkg_a YAML 2 3 a_Comp4 arg1 var1 Output: X \u251c\u2500\u2500 config.go \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 internal \u2502 \u251c\u2500\u2500 sw.cfg \u2502 \u251c\u2500\u2500 sw.tmpl \u2502 \u251c\u2500\u2500 X \u2502 \u251c\u2500\u2500 X.go \u2502 \u2514\u2500\u2500 X.sw \u251c\u2500\u2500 pkg_a \u2502 \u251c\u2500\u2500 a_Comp4.go \u2502 \u2514\u2500\u2500 a_Comp4_test.go \u251c\u2500\u2500 X.yaml \u251c\u2500\u2500 Y \u2502 \u251c\u2500\u2500 Comp1.go \u2502 \u251c\u2500\u2500 Comp1_test.go \u2502 \u251c\u2500\u2500 Comp2.go \u2502 \u251c\u2500\u2500 Comp2_test.go \u2502 \u251c\u2500\u2500 Comp3.go \u2502 \u2514\u2500\u2500 Comp3_test.go \u2514\u2500\u2500 Z \u251c\u2500\u2500 Comp1.go \u251c\u2500\u2500 Comp1_test.go \u251c\u2500\u2500 Comp2.go \u251c\u2500\u2500 Comp2_test.go \u251c\u2500\u2500 Comp3.go \u2514\u2500\u2500 Comp3_test.go 4 directories, 23 files","title":"Add a component/package to a module:"},{"location":"SECURITY/","text":"Security Policy Supported Versions Version Supported 0.27.0 :white_check_mark: < 1.0.0 :x: Reporting a Vulnerability E-mail streamwork_security@twyoung.com to report a vulnerability. Please do not expect acknowlegement or e-mail responses of any kind. Watch the github repo for appropriate updates. There are currently no known security problems. We greatly appreciate your help in keeping things that way. Let us know in your e-mail if you wish to be publicly acknowledged, or not.","title":"Security"},{"location":"SECURITY/#security-policy","text":"","title":"Security Policy"},{"location":"SECURITY/#supported-versions","text":"Version Supported 0.27.0 :white_check_mark: < 1.0.0 :x:","title":"Supported Versions"},{"location":"SECURITY/#reporting-a-vulnerability","text":"E-mail streamwork_security@twyoung.com to report a vulnerability. Please do not expect acknowlegement or e-mail responses of any kind. Watch the github repo for appropriate updates. There are currently no known security problems. We greatly appreciate your help in keeping things that way. Let us know in your e-mail if you wish to be publicly acknowledged, or not.","title":"Reporting a Vulnerability"},{"location":"about/","text":"About StreamWork -v0.26.6 Report an issue to sw@twyoung.com References Semantic Versioning Github Markdown","title":"About"},{"location":"about/#about-streamwork-v0266","text":"Report an issue to sw@twyoung.com","title":"About StreamWork -v0.26.6 "},{"location":"about/#references","text":"Semantic Versioning Github Markdown","title":"References"},{"location":"components/","text":"StreamWork Components The StreamWork project provides a set of tested, re-entrant, standard StreamWork components, available at GitHub . Standard components communicate over Go channel interfaces. StreamWork components are contained as exported functions within Go packages. They are documented by package(SwBase, SwUtility, etc.) immediately below. To prevent race conditions, there are no global variables in standard components. Global variables should be avoided in non-standard components also.","title":"Components"},{"location":"components/#streamwork-components","text":"The StreamWork project provides a set of tested, re-entrant, standard StreamWork components, available at GitHub . Standard components communicate over Go channel interfaces. StreamWork components are contained as exported functions within Go packages. They are documented by package(SwBase, SwUtility, etc.) immediately below. To prevent race conditions, there are no global variables in standard components. Global variables should be avoided in non-standard components also.","title":"StreamWork Components"},{"location":"design/","text":"StreamWork Design Guidelines GO Design Guidelines Separate concerns GUI, business logic, DB, etc. should not be intermixed. Try to make the business logic clear to the business experts and easily modifiable. Use decision tables, graphs, etc. Do not avoid the GO init() function. The init() function in all processes will execute, in parallel, prior to any main function. For instance, one process could set the DEBUG variable on within its init() function, causing all processes to continue in DEBUG mode. Simple interfaces Avoid global variables. Ensure components are re-entrant. Limit each channel to one type of data. Pass a structure, instead of multiple data elements. Pass structures or handles, rather than pointers. A data tree can be passed in abstract syntax form, then reconstructed on receipt. Strive for less than four channels per component, splitting into multiple components if necessary. Exception: same IP type on multiple channels. Don't over simplify and create too many fine-grained processes. Use simple URI rules URI Rules Don't buffer unnecessarily. Zero-length buffers are a bit more secure and minimize latency. In come cases, particularly in cyclic networks, however, non-zero buffers may be necessary to prevent deadlock. Non-zero buffers may also speed processing sometimes. Note that Go uses ring buffers, implying that IPs can be received even when the buffer is not full. Buffers can be useful when input arrives erratically. Security and synchronization Always defer synchronizing waits to help prevent deadlock and zombies. Avoid threats (see Go security practices ) Validate input entries Use HTML templates to help avoid cross site script(CSS) attacks Prevent SQL injections Encrypt sensitive data Use HTTPS, not http Use logs and error messages carefully, being sure to avoid leaking sensitive data. (5,000 secrets/day are leaked to GitHub, it has been claimed.) Document at the component, subnet, and package levels. Test at the component and package levels. StreamWork Features StreamWork: does not complicate debugging with subnet logic. Subnets are purely design aids. does not process IPs; it merely creates a channel for every stream, assigning the channels to the sending and receiving components; has a number of rules for automatically connecting ports according to their names and modes(sink or source) ; implements a text based, context free, program language agnostic, network definition language, SWL; produces pure Go code with no dependencies other than those required by the components themselves; (The generated code, should run on any platform Go supports. Non-standard components may contain OS dependent code, however.) Component behavior can be controlled via arguments, environment variables, in-stream commands, ordinary IPs, and signals. Each process runs as an independent Go routine. Components are free to launch and synchonize Go routines of their own.","title":"Design Guidelines"},{"location":"design/#streamwork-design-guidelines","text":"","title":"StreamWork Design Guidelines"},{"location":"design/#go-design-guidelines","text":"Separate concerns GUI, business logic, DB, etc. should not be intermixed. Try to make the business logic clear to the business experts and easily modifiable. Use decision tables, graphs, etc. Do not avoid the GO init() function. The init() function in all processes will execute, in parallel, prior to any main function. For instance, one process could set the DEBUG variable on within its init() function, causing all processes to continue in DEBUG mode. Simple interfaces Avoid global variables. Ensure components are re-entrant. Limit each channel to one type of data. Pass a structure, instead of multiple data elements. Pass structures or handles, rather than pointers. A data tree can be passed in abstract syntax form, then reconstructed on receipt. Strive for less than four channels per component, splitting into multiple components if necessary. Exception: same IP type on multiple channels. Don't over simplify and create too many fine-grained processes. Use simple URI rules URI Rules Don't buffer unnecessarily. Zero-length buffers are a bit more secure and minimize latency. In come cases, particularly in cyclic networks, however, non-zero buffers may be necessary to prevent deadlock. Non-zero buffers may also speed processing sometimes. Note that Go uses ring buffers, implying that IPs can be received even when the buffer is not full. Buffers can be useful when input arrives erratically. Security and synchronization Always defer synchronizing waits to help prevent deadlock and zombies. Avoid threats (see Go security practices ) Validate input entries Use HTML templates to help avoid cross site script(CSS) attacks Prevent SQL injections Encrypt sensitive data Use HTTPS, not http Use logs and error messages carefully, being sure to avoid leaking sensitive data. (5,000 secrets/day are leaked to GitHub, it has been claimed.) Document at the component, subnet, and package levels. Test at the component and package levels.","title":"GO Design Guidelines"},{"location":"design/#streamwork-features","text":"StreamWork: does not complicate debugging with subnet logic. Subnets are purely design aids. does not process IPs; it merely creates a channel for every stream, assigning the channels to the sending and receiving components; has a number of rules for automatically connecting ports according to their names and modes(sink or source) ; implements a text based, context free, program language agnostic, network definition language, SWL; produces pure Go code with no dependencies other than those required by the components themselves; (The generated code, should run on any platform Go supports. Non-standard components may contain OS dependent code, however.) Component behavior can be controlled via arguments, environment variables, in-stream commands, ordinary IPs, and signals. Each process runs as an independent Go routine. Components are free to launch and synchonize Go routines of their own.","title":"StreamWork Features"},{"location":"github/","text":"Link to Githhub","title":"Github Project"},{"location":"github/#link-to-githhub","text":"","title":"Link to Githhub"},{"location":"license/","text":"Copyright (C) 2019,2020,2021,2022 Thomas W. Young, sw@twyoung.com Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file or its derivitaves except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. All files in this repo are included in this license.","title":"License"},{"location":"mkdocs/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Mkdocs"},{"location":"mkdocs/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"mkdocs/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"mkdocs/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"rdm/","text":"STREAMWORK -- SW-0.27.0 Copyright (C) 2019,2020,2021,2022 Thomas W. Young, sw@twyoung.com Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file or its derivitaves except in compliance with the License. You may obtain a copy of the License at Apache License Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. All files in this repo are included in this license. StreamWork Go language code generator. Contents Description Synopsis Return code TestSWL program Network Definition Network Definition Files QuickStart on Linux Requirements Installation Post Install Foo Bar test Building on Linux StreamWork Language(SWL) Notes Stream types and component arguments Variables Semi-colon commentary Left Arrow comments Collate/Merge Example Bash Scripts Hello World swgo script swgraph Script gofbp script gofbp Example LOADBAL.SW Generate a project sw.sh Synopsis BUGS Home Page Release Notes Author Description StreamWork is a simple system for building complex programs. StreamWork can generate and test a complete Golang project from a simple text file. It can also create a nice graph showing the components and their connections. By default, StreamWork reads, parses, and analyzes; a simple SWL language StreamWork network definition(ND) file, then generates a main Go program. Options allow you to produce an abstract syntax tree, a GraphViz dot file, or a goFBP main prgram instead. Synopsis sw [-m MODE] [-cfg CONFIGURATION_FILE] [-d DEFAULT_PATH] [ SW_FILE ] sw -v sw --help If SW_FILE is omitted, sw will read from stdin. MODE= 0-GOMODE . Generate a main SW Go program[DEFAULT]. 1-ASTMODE . Display the Abstract Syntax Tree 2-GENTREE . Display the Linearized tree 3-GRAPHMODE . Generate Graphviz .dot file code 4-JAVAFBP . Incomplete and untested. Looking for help. 5-PROJECT . Generate **_swgen.sh_** code for a project tree. 7-CMODE . Incomplete and untested. Looking for help. 8-GENGOFBP . Generate main go code for J. P. Morrison's gofbp. Return code sw returns SUCCESS unless it encounters an error, in which case sw returns FAILURE. See package documention for component return codes. TestSWL program TestSWL syntax checks stdin or a SteamWork network definition file or a SteamWork configuration file. synopsis usage: Call with one of the following argument combinations: --help Display this help message. (no arguments) Parse stdin verbosely. (files) Parse content of files verbosely. -s (files) Silent mode. Parse content of files silently. Network Definition A StreamWork network definition describes a program as a list of data streams. Each data stream consists of a source process, a director, and a sink process. The network definition is a compact text-based representation of a data flow diagram. StreamWork is concerned primarily with Go language FBP programs, however, the network definition described here is language agnostic. It is quite possible to generate corresponding code in other languages from a StreamWork ND. The script, swgo , reads and executes an ND employing sw to properly launch and connect the processes. By default, sw generates and builds a single main Go program which: * imports sw compatible component package(s) as specified in the network definition, * launches a goroutine for each process, * connects these processes via Golang interface channels, and * waits for all processes to finish. * StreamWork has no other interaction with the component processes, which do not call on StreamWork functions in any way. On option, sw will read, parse and interpret a network definition file then create either a: a StreamWork Go main program, a gofbp Go main program (see github.com/jpaulm/gofbp), a GraphViz .dot file(script,( swgraph will create and display a graph(s) directly) a bash script, ( swproject generates a complete GO language project tree and tests it) an abstract syntax tree (a reverse polish notation rendition of the essential language components), OR a linearized tree (a network definition reconstruction). Network Definition Files A network definition file (in the SWL language[see below]) consists of a list of streams(aka dataflows); and may also contain subnet definitions, INCLUDE and PREFIX statements, and comments. INCLUDEd files are also network definitions which may in turn contain INCLUDE statements. Exceeding 100 levels of includes will cause program termination. A stream definition looks something like: (a C \"ARG...\" ) -ipType> (b D); or [reversing direction and using default component names] (E)IN <- OUT.1(F)0 <- (G); and consists of a list of streams. Each stream consists of a source process, a stream director, a sink process and a terminating semicolon(;). Each process consists of a processname optional component identifier optional string arguments, and optional process attributes [surrounded by brackets]. Attributes consist of KEY=STRING|NUMBER statements, used mainly to enhance graphic images. all surrounded by parens, and followed and/or preceded by optional port identifiers consisting of a port number preceded by an optional port name and period(.). Omitted port identifiers default to zero(0). The stream director points from the source process to the sink process. A director may include a type identifier and/or a stream buffer size: e.g. \" \". If not included, buffer size defaults to zero. Example with anonymous process names and default components: (_) -int 3> (_); #[integer stream with buffersize of three]; In this example, the default components [as specified in a config file, send their process names to the channel or to stdout: (Hello) <- (World); produces: Hello World A process is defined by its process name, its component identifier, component arguments, and process attributes; all surrounded by parens. The component identifier, arguments, and attributes will default if omitted. Process names are not apparent to Go and so need not follow Go naming rules, just the StreamWork conventions. A component identifier consists of its import module/package identifier, a slash, '/', and the component name. Go component names need to be capitalized.type If the path is omitted, a configuration default path is assumed. If the component name is also omitted, configuration default component names are assumed for sink, source, and filter(has both inputs and outputs) processes. Subnet components are identified by ' prefixing its identifier, as in (A ^SubnetName) ... Stream directors consist of < , an optional, comma-separated list of type identifiers, an optional buffersize integer, and - . Example: <100- The reverse (Ex: -myDataType,yourType 100> ) is also valid. Information packets(IPs) are designed as nitypel(empty) interfaces. The data type is determined by the sending component. It is possible for properly coded sink components to handle multiple data types. A type mis-match will be reported by incompatible receiving components. Components can be coded to handle any type(including user-defined types and structures). Some components (sw.Print, for instance) can process strings and integers; some just a single type; on each receiving port. sw versions beginning with v1.0.0 are backward compatible within the same major version(currently v0). There is no such guarantee with v0.N.N versions, but we will increase the minor version in such cases. The master github branch may have many commits without creating a new version. sw builds a network model in memory, then optionally generates either an abstract syntax tree, a linearized tree(a network definition reconstruction), a GraphViz .dot file, input to swproject to build a complete working project tree, or Go source code from the network model. or Go main source code for JFM's gofbp. C and other languages could also be generated, but this has not been implemented. JavaFBP is also possible. Comments and critiques are welcome. Contributors are encouraged. Please do not submit code before contacting the project. Contact by e-mailing streamwork@twyoung.com or Discord/gofbp message is preferred to posting a request on Github. QuickStart on Linux Requirements Gcc, etc. Graphviz should be installed, but installation may proceed without it. The ...github/tyoung3/StreamWork backend is no longer required. sw is written in C. Installation cd to any convenient workspace (/usr/local/src for example). Download the latest sw-0.27.0.tar.gz file from https://github.com/tyoung3/sw/build Run 'tar -xzf .../sw-0.27.0.tar.gz' to extract source files cd sw-0.27.0 Run ./configure && make check Run sudo make install. sw and associated scripts will be installed in /usr/local/bin Post Install Foo Bar test mkdir /tmp/x/ * echo \"(Foo) <- (Bar);\" | sw > /tmp/x/fb.go cd /tmp/x/ go mod tidy Run: go run /tmp/fb.go This is what the swgo script does: try swgo .../nds/fb.sw OUTPUT: Foo Bar-1 Foo Bar-2 Foo Bar-3 Foo Bar-4 Foo Bar-5 Foo Bar-6 Foo Bar-7 Building on Linux Install autotools, ctags, libyaml-dev, bnfc, bison, and flex cd to your project workspace (like /usr/local/src ) git clone https://github.com/tyoung3/sw.git bin/sw.sh build; # Runs autotools including .../sw/bin/configure. bin/sw.sh c; # Runs make check in .../sw/src bin/sw.sh bw; # Builds Windows/sw.exe. Requires mingw. Run make distclean first. StreamWork Language(SWL) Notes SWL is an unambiguous, context free grammar, making it directly interpretable, without preprocessing. See the bnfc StreamWork language description file, SWL.pdf. SWL has few reserved words, making it somewhat natural language agnostic. There is no guarantee this condition will continue, however, every effort will be made to ensure that all currently valid SWL statements will remain valid. Should this prove impossible, the minor version will be incremented. Once v1.0.0 is reached, the major version will be incremented instead. Backward conpatibility is enforced for network definition files, sw , and published Go modules only. Linux scripts and Go modules, are separately versioned. Stream types and component arguments Stream channels can be any Go language type: int, string, struct, or interface. '_' is shorthand for an interface channel type. Components with channels of varying types, should group types to simplify their entry points. Autojoin and autosplit work only with interface types. While StreamWork packages a number of components, none of them are required. It is quite possible to define a network with no dependencies (other than Go packages) at all. The only requirement for a component is an entry point with two or more parameters: wait group, argument string slice, and as many channel slices as there are channel types. Variables SWL accepts string($NAME), environment string($_NAME), symbol(&NAME), and numeric(%NAME) variables. See SWL.pdf for acceptable usage. StreamWork uses the following environment variables: * $BROWSER -- WWW browser * $GOPATH -- Go language path * $DEBUG -- 'Y' will cause some messages to print. Semi-colon commentary Statements in SWL, are terminated with a semi-colon. Semi-colons in code are like periods at the end of English statements -- they tell the reader (and the SWL interpreter) when you have reached the end of a statement; making reading the statements easier. Imagine trying to read a book without any periods (or initial capitals). Additionally, without semi-colons line breaks become part of the language definition, leading to awkward, confusing syntax rules. Left Arrow comments The, <- , token is employed in order to be consistent with its usage in the Go language. The -> token is also available: \"(A) -> (B)1 <- (C);\" is valid SWL. Collate/Merge Example Run the following (in Linux): mkdir /tmp/collate sw < sw/nds/collate.sw > /tmp/collate.go go run /tmp/collate.go |grep Match0 to produce: Match0 Int: 5 Match0 Int: 7 Match0 Int: 9 Match0 Int: 11 Match0 Int: 17 Match0 Int: 23 Hello World echo \"(HELLO)->(WORLD);\" |sw > /tmp/hello.go go run /tmp/hello.go Produces: WORLD HELLO-1 WORLD HELLO-2 WORLD HELLO-3 WORLD HELLO-4 WORLD HELLO-5 WORLD HELLO-6 WORLD HELLO-7 sw -m 3 < sw/nds/collate.sw | dot -Tsvg > /tmp/collate.svg produces an image of the collate network. Bash Scripts swgo script The bash script, swgo , will generate and run a GO program from a network definition: .../nds/hw.sw (Hello) <string- (World); swgo .../nds/hw produces: package main /* StreamWork Go code. Generated by sw/swgo.c-0.22.0 Wed Mar 16 14:48:30 2022 from Network file: /usr/local/src/sw/src/nds/hw.sw Configuration file: /usr/local/src/sw/src/nds/sw.cfg *** Expanded Network Definition *** (Hello sw.Print ) <_- 0(World sw.Gens); 1 stream, 2 processes, 2 components, 1 partition, 0 cycles. */ import \"sync\" import \"github.com/tyoung3/sw\" func main() { var wg sync.WaitGroup cs0 := make(chan interface{},0) //World.0->Hello.0 wg.Add(1) var cp1 []chan interface{} cp1=append(cp1,cs0) go sw.Gens(&wg,[]string{\"World\"},cp1) // World var cp2 []chan interface{} cp2=append(cp2,cs0) go sw.Print(&wg,[]string{\"Hello\"},cp2) // Hello wg.Wait() } Which in turn produces: Hello World-1 Hello World-2 Hello World-3 Hello World-4 Hello World-5 Hello World-6 swgraph Script Another bash script, swgraph , will display a graphic image of a network definition: .../nds/mvc.sw (m Model)1 -change> (v View); (c)2 -update> 1(v); (v)2 -event> (c Control); (c)1 -request> (m); swgraph .../nds/mvc produces: for instance. Processes are colored such that all components in the same package have the same color. Not shown here, unfortunately, are the tooltips and html references. Arrows are colored according to stream buffersize: 0 - black; 1-green; 2 or more - orange. Coloring rules are not guaranteed to remain unchanged in future sw versions. WARNING: buffersize is related to deadlock potential in cyclic networks. The resulting image is an annotated Data Flow Diagram. gofbp script gofbp produces and runs a gofbp program (see github.com/jpaulm/gofbp ) from a StreamWork net definition file. gofbp Example (from sw/src/model/tests/gofbp/loadbal.sw) Given: LOADBAL.SW $core = \"github.com/jpaulm/gofbp/core\"; $trtn = \"github.com/jpaulm/gofbp/components/testrtn\"; (Sender $trtn/Sender \"10 COUNT=10\")OUT -load> IN.0(LoadBalance $trtn/LoadBalance ); (LoadBalance)OUT.1 -load> IN(Receiver0 $trtn/DelayedReceiver); (LoadBalance)OUT.2 -load> IN(Receiver1 $trtn/Receiver); (LoadBalance)OUT.3 -load> IN(Receiver2 $trtn/Receiver); gofbp -b loadbal produces and (on console) Input to Receiver: Receiver1 > IP - # 1 Input to Receiver: Receiver1 > IP - # 4 Input to Receiver: Receiver1 > IP - # 6 Input to Receiver: Receiver1 > IP - # 8 Input to Receiver: Receiver2 > IP - # 0 Input to Receiver: Receiver2 > IP - # 3 Input to Receiver: Receiver2 > IP - # 7 Input to DelayedReceiver: Receiver0 > IP - # 2 Input to DelayedReceiver: Receiver0 > IP - # 5 Input to DelayedReceiver: Receiver0 > IP - # 9 Generate a project swproject .../nds/postage.sw produces the following source tree: postage \u251c\u2500\u2500 addr \u2502 \u251c\u2500\u2500 GetDest.go \u2502 \u2514\u2500\u2500 GetDest_test.go \u251c\u2500\u2500 ComputePostage.go \u251c\u2500\u2500 ComputePostage_test.go \u251c\u2500\u2500 config.go \u251c\u2500\u2500 getr \u2502 \u251c\u2500\u2500 Rates.go \u2502 \u2514\u2500\u2500 Rates_test.go \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 internal \u2502 \u251c\u2500\u2500 gen_swproject \u2502 \u251c\u2500\u2500 postage.go \u2502 \u251c\u2500\u2500 postage.sw \u2502 \u2514\u2500\u2500 sw.cfg \u251c\u2500\u2500 postage.yaml \u251c\u2500\u2500 PrintLabel.go \u2514\u2500\u2500 PrintLabel_test.go then produces this graph vets the code, and finally runs it. sw.sh Synopsis sw.sh-1.0.1 USAGE: b|build . Build project with Autotools. c . Make check cl . Show release check list. d [OPTs] . Switch to docker container. e . Exit SW shell. d build [OPTs] . Build SWdemo docker container. doc . Run and browse Doxygen j . Graph collate.sw with swgraph jl . Generate and view locusts.png p [NAME..] . Generate project(s) named NAME... poc . Build and run Proof of Concept rm . View README in /opt/google/chrome/chrome rc . Build and run Collate program rl . Run locusts program s . Enter SW shell. 'e' to exit the shell. v . Display this script version x . Edit this script --help . Display this help BUGS: sw.Gen fails unless all three arguments are present. Stream directors like => and <= are accepted, but treated the same as -> and <-, except for appearing differently in graphs. The meaning is reserved for future use, which could break existing networks. Home Page (https://sw.twyoung.com) Release Notes 0.18.0 Reorganized repo tree structure Renamed package swbase to sw and moved code to repo root Changed package swutility to import package sw 0.18.4 Fixes for restructure problems Fixes to bash scripts Fixes to githup builds 0.18.5 More fixes Moved .../sw/c to .../sw/src 0.18.6 Created gofbp script Added sw/testrtn package 0.18.7 Moved build process to project tree root 0.18.8 Fixed count in swbal.sw 0.18.9 Fix testrtn/Sender 0.19.0 Many fixes to swproject script 0.20.1 Fix swgraph file search 0.20.6 Incorporate component attributes in SWL for future graphing enhancements. Fix fan logic when connection is missing. 0.20.7 Improve gofbp script Update README 0.20.8 Created fileio package with GetFile and PutFile and FileT 0.20.10 Provide process attributes. 0.21.0 Can generate projects with or without YAML configuration. Fixes to Wrap function. 0.21.1 README updates Updated SWL.pdf 0.22.0 Go code generation revamped Typed channels partly implemented, possibly breaking networks with types specified in a director. 0.26.6 Fixed double arrow graph error 0.26.7 Introduced mkdocs Attempt to fix go.in yaml Dependabot alert Fix build error in swgraph.c 0.26.8 Removed 'default:' error from swgraph.c 0.26.9 Fixed bug with subnet attributes 0.26.10 Fixed maximum subnet level checking Introducted mkdocs web site docs 0.26.11 Changed type mismatches from FAILing to WARNING. 0.27.0 Changed package name from sw/linux to sw/os Added sw/os/Debug function Author Tom Young, streamwork@twyoung.com with thanks to J. Paul Morrison, Phillip W. Young, Sam Watkins, the contributors to flow-based-programming@googlegroups.com, and to the developers/maintainers of Go, gcc, Linux/Ubuntu, BNFC, git, GraphViz, Github and others.","title":"Readme"},{"location":"rdm/#streamwork-sw-0270","text":"Copyright (C) 2019,2020,2021,2022 Thomas W. Young, sw@twyoung.com Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file or its derivitaves except in compliance with the License. You may obtain a copy of the License at Apache License Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. All files in this repo are included in this license.","title":"STREAMWORK -- SW-0.27.0"},{"location":"rdm/#streamwork","text":"Go language code generator.","title":"StreamWork"},{"location":"rdm/#contents","text":"Description Synopsis Return code TestSWL program Network Definition Network Definition Files QuickStart on Linux Requirements Installation Post Install Foo Bar test Building on Linux StreamWork Language(SWL) Notes Stream types and component arguments Variables Semi-colon commentary Left Arrow comments Collate/Merge Example Bash Scripts Hello World swgo script swgraph Script gofbp script gofbp Example LOADBAL.SW Generate a project sw.sh Synopsis BUGS Home Page Release Notes Author","title":"Contents"},{"location":"rdm/#description","text":"StreamWork is a simple system for building complex programs. StreamWork can generate and test a complete Golang project from a simple text file. It can also create a nice graph showing the components and their connections. By default, StreamWork reads, parses, and analyzes; a simple SWL language StreamWork network definition(ND) file, then generates a main Go program. Options allow you to produce an abstract syntax tree, a GraphViz dot file, or a goFBP main prgram instead.","title":"Description"},{"location":"rdm/#synopsis","text":"sw [-m MODE] [-cfg CONFIGURATION_FILE] [-d DEFAULT_PATH] [ SW_FILE ] sw -v sw --help If SW_FILE is omitted, sw will read from stdin. MODE= 0-GOMODE . Generate a main SW Go program[DEFAULT]. 1-ASTMODE . Display the Abstract Syntax Tree 2-GENTREE . Display the Linearized tree 3-GRAPHMODE . Generate Graphviz .dot file code 4-JAVAFBP . Incomplete and untested. Looking for help. 5-PROJECT . Generate **_swgen.sh_** code for a project tree. 7-CMODE . Incomplete and untested. Looking for help. 8-GENGOFBP . Generate main go code for J. P. Morrison's gofbp.","title":"Synopsis"},{"location":"rdm/#return-code","text":"sw returns SUCCESS unless it encounters an error, in which case sw returns FAILURE. See package documention for component return codes.","title":"Return code"},{"location":"rdm/#testswl-program","text":"TestSWL syntax checks stdin or a SteamWork network definition file or a SteamWork configuration file.","title":"TestSWL program"},{"location":"rdm/#synopsis_1","text":"usage: Call with one of the following argument combinations: --help Display this help message. (no arguments) Parse stdin verbosely. (files) Parse content of files verbosely. -s (files) Silent mode. Parse content of files silently.","title":"synopsis"},{"location":"rdm/#network-definition","text":"A StreamWork network definition describes a program as a list of data streams. Each data stream consists of a source process, a director, and a sink process. The network definition is a compact text-based representation of a data flow diagram. StreamWork is concerned primarily with Go language FBP programs, however, the network definition described here is language agnostic. It is quite possible to generate corresponding code in other languages from a StreamWork ND. The script, swgo , reads and executes an ND employing sw to properly launch and connect the processes. By default, sw generates and builds a single main Go program which: * imports sw compatible component package(s) as specified in the network definition, * launches a goroutine for each process, * connects these processes via Golang interface channels, and * waits for all processes to finish. * StreamWork has no other interaction with the component processes, which do not call on StreamWork functions in any way. On option, sw will read, parse and interpret a network definition file then create either a: a StreamWork Go main program, a gofbp Go main program (see github.com/jpaulm/gofbp), a GraphViz .dot file(script,( swgraph will create and display a graph(s) directly) a bash script, ( swproject generates a complete GO language project tree and tests it) an abstract syntax tree (a reverse polish notation rendition of the essential language components), OR a linearized tree (a network definition reconstruction).","title":"Network Definition "},{"location":"rdm/#network-definition-files","text":"A network definition file (in the SWL language[see below]) consists of a list of streams(aka dataflows); and may also contain subnet definitions, INCLUDE and PREFIX statements, and comments. INCLUDEd files are also network definitions which may in turn contain INCLUDE statements. Exceeding 100 levels of includes will cause program termination. A stream definition looks something like: (a C \"ARG...\" ) -ipType> (b D); or [reversing direction and using default component names] (E)IN <- OUT.1(F)0 <- (G); and consists of a list of streams. Each stream consists of a source process, a stream director, a sink process and a terminating semicolon(;). Each process consists of a processname optional component identifier optional string arguments, and optional process attributes [surrounded by brackets]. Attributes consist of KEY=STRING|NUMBER statements, used mainly to enhance graphic images. all surrounded by parens, and followed and/or preceded by optional port identifiers consisting of a port number preceded by an optional port name and period(.). Omitted port identifiers default to zero(0). The stream director points from the source process to the sink process. A director may include a type identifier and/or a stream buffer size: e.g. \" \". If not included, buffer size defaults to zero. Example with anonymous process names and default components: (_) -int 3> (_); #[integer stream with buffersize of three]; In this example, the default components [as specified in a config file, send their process names to the channel or to stdout: (Hello) <- (World); produces: Hello World A process is defined by its process name, its component identifier, component arguments, and process attributes; all surrounded by parens. The component identifier, arguments, and attributes will default if omitted. Process names are not apparent to Go and so need not follow Go naming rules, just the StreamWork conventions. A component identifier consists of its import module/package identifier, a slash, '/', and the component name. Go component names need to be capitalized.type If the path is omitted, a configuration default path is assumed. If the component name is also omitted, configuration default component names are assumed for sink, source, and filter(has both inputs and outputs) processes. Subnet components are identified by ' prefixing its identifier, as in (A ^SubnetName) ... Stream directors consist of < , an optional, comma-separated list of type identifiers, an optional buffersize integer, and - . Example: <100- The reverse (Ex: -myDataType,yourType 100> ) is also valid. Information packets(IPs) are designed as nitypel(empty) interfaces. The data type is determined by the sending component. It is possible for properly coded sink components to handle multiple data types. A type mis-match will be reported by incompatible receiving components. Components can be coded to handle any type(including user-defined types and structures). Some components (sw.Print, for instance) can process strings and integers; some just a single type; on each receiving port. sw versions beginning with v1.0.0 are backward compatible within the same major version(currently v0). There is no such guarantee with v0.N.N versions, but we will increase the minor version in such cases. The master github branch may have many commits without creating a new version. sw builds a network model in memory, then optionally generates either an abstract syntax tree, a linearized tree(a network definition reconstruction), a GraphViz .dot file, input to swproject to build a complete working project tree, or Go source code from the network model. or Go main source code for JFM's gofbp. C and other languages could also be generated, but this has not been implemented. JavaFBP is also possible. Comments and critiques are welcome. Contributors are encouraged. Please do not submit code before contacting the project. Contact by e-mailing streamwork@twyoung.com or Discord/gofbp message is preferred to posting a request on Github.","title":"Network Definition Files"},{"location":"rdm/#quickstart-on-linux","text":"","title":"QuickStart on Linux"},{"location":"rdm/#requirements","text":"Gcc, etc. Graphviz should be installed, but installation may proceed without it. The ...github/tyoung3/StreamWork backend is no longer required. sw is written in C.","title":"Requirements"},{"location":"rdm/#installation","text":"cd to any convenient workspace (/usr/local/src for example). Download the latest sw-0.27.0.tar.gz file from https://github.com/tyoung3/sw/build Run 'tar -xzf .../sw-0.27.0.tar.gz' to extract source files cd sw-0.27.0 Run ./configure && make check Run sudo make install. sw and associated scripts will be installed in /usr/local/bin","title":"Installation"},{"location":"rdm/#post-install","text":"","title":"Post Install"},{"location":"rdm/#foo-bar-test","text":"mkdir /tmp/x/ * echo \"(Foo) <- (Bar);\" | sw > /tmp/x/fb.go cd /tmp/x/ go mod tidy Run: go run /tmp/fb.go This is what the swgo script does: try swgo .../nds/fb.sw OUTPUT: Foo Bar-1 Foo Bar-2 Foo Bar-3 Foo Bar-4 Foo Bar-5 Foo Bar-6 Foo Bar-7","title":"Foo Bar test"},{"location":"rdm/#building-on-linux","text":"Install autotools, ctags, libyaml-dev, bnfc, bison, and flex cd to your project workspace (like /usr/local/src ) git clone https://github.com/tyoung3/sw.git bin/sw.sh build; # Runs autotools including .../sw/bin/configure. bin/sw.sh c; # Runs make check in .../sw/src bin/sw.sh bw; # Builds Windows/sw.exe. Requires mingw. Run make distclean first.","title":"Building on Linux"},{"location":"rdm/#streamwork-languageswl-notes","text":"SWL is an unambiguous, context free grammar, making it directly interpretable, without preprocessing. See the bnfc StreamWork language description file, SWL.pdf. SWL has few reserved words, making it somewhat natural language agnostic. There is no guarantee this condition will continue, however, every effort will be made to ensure that all currently valid SWL statements will remain valid. Should this prove impossible, the minor version will be incremented. Once v1.0.0 is reached, the major version will be incremented instead. Backward conpatibility is enforced for network definition files, sw , and published Go modules only. Linux scripts and Go modules, are separately versioned.","title":"StreamWork Language(SWL) Notes"},{"location":"rdm/#stream-types-and-component-arguments","text":"Stream channels can be any Go language type: int, string, struct, or interface. '_' is shorthand for an interface channel type. Components with channels of varying types, should group types to simplify their entry points. Autojoin and autosplit work only with interface types. While StreamWork packages a number of components, none of them are required. It is quite possible to define a network with no dependencies (other than Go packages) at all. The only requirement for a component is an entry point with two or more parameters: wait group, argument string slice, and as many channel slices as there are channel types.","title":"Stream types and component arguments"},{"location":"rdm/#variables","text":"SWL accepts string($NAME), environment string($_NAME), symbol(&NAME), and numeric(%NAME) variables. See SWL.pdf for acceptable usage. StreamWork uses the following environment variables: * $BROWSER -- WWW browser * $GOPATH -- Go language path * $DEBUG -- 'Y' will cause some messages to print.","title":"Variables"},{"location":"rdm/#semi-colon-commentary","text":"Statements in SWL, are terminated with a semi-colon. Semi-colons in code are like periods at the end of English statements -- they tell the reader (and the SWL interpreter) when you have reached the end of a statement; making reading the statements easier. Imagine trying to read a book without any periods (or initial capitals). Additionally, without semi-colons line breaks become part of the language definition, leading to awkward, confusing syntax rules.","title":"Semi-colon commentary"},{"location":"rdm/#left-arrow-comments","text":"The, <- , token is employed in order to be consistent with its usage in the Go language. The -> token is also available: \"(A) -> (B)1 <- (C);\" is valid SWL.","title":"Left Arrow comments"},{"location":"rdm/#collatemerge-example","text":"Run the following (in Linux): mkdir /tmp/collate sw < sw/nds/collate.sw > /tmp/collate.go go run /tmp/collate.go |grep Match0 to produce: Match0 Int: 5 Match0 Int: 7 Match0 Int: 9 Match0 Int: 11 Match0 Int: 17 Match0 Int: 23","title":"Collate/Merge Example"},{"location":"rdm/#hello-world","text":"echo \"(HELLO)->(WORLD);\" |sw > /tmp/hello.go go run /tmp/hello.go Produces: WORLD HELLO-1 WORLD HELLO-2 WORLD HELLO-3 WORLD HELLO-4 WORLD HELLO-5 WORLD HELLO-6 WORLD HELLO-7 sw -m 3 < sw/nds/collate.sw | dot -Tsvg > /tmp/collate.svg produces an image of the collate network.","title":"Hello World"},{"location":"rdm/#bash-scripts","text":"","title":"Bash Scripts"},{"location":"rdm/#swgo-script","text":"The bash script, swgo , will generate and run a GO program from a network definition: .../nds/hw.sw (Hello) <string- (World); swgo .../nds/hw produces: package main /* StreamWork Go code. Generated by sw/swgo.c-0.22.0 Wed Mar 16 14:48:30 2022 from Network file: /usr/local/src/sw/src/nds/hw.sw Configuration file: /usr/local/src/sw/src/nds/sw.cfg *** Expanded Network Definition *** (Hello sw.Print ) <_- 0(World sw.Gens); 1 stream, 2 processes, 2 components, 1 partition, 0 cycles. */ import \"sync\" import \"github.com/tyoung3/sw\" func main() { var wg sync.WaitGroup cs0 := make(chan interface{},0) //World.0->Hello.0 wg.Add(1) var cp1 []chan interface{} cp1=append(cp1,cs0) go sw.Gens(&wg,[]string{\"World\"},cp1) // World var cp2 []chan interface{} cp2=append(cp2,cs0) go sw.Print(&wg,[]string{\"Hello\"},cp2) // Hello wg.Wait() } Which in turn produces: Hello World-1 Hello World-2 Hello World-3 Hello World-4 Hello World-5 Hello World-6","title":"swgo script"},{"location":"rdm/#swgraph-script","text":"Another bash script, swgraph , will display a graphic image of a network definition: .../nds/mvc.sw (m Model)1 -change> (v View); (c)2 -update> 1(v); (v)2 -event> (c Control); (c)1 -request> (m); swgraph .../nds/mvc produces: for instance. Processes are colored such that all components in the same package have the same color. Not shown here, unfortunately, are the tooltips and html references. Arrows are colored according to stream buffersize: 0 - black; 1-green; 2 or more - orange. Coloring rules are not guaranteed to remain unchanged in future sw versions. WARNING: buffersize is related to deadlock potential in cyclic networks. The resulting image is an annotated Data Flow Diagram.","title":"swgraph Script"},{"location":"rdm/#gofbp-script","text":"gofbp produces and runs a gofbp program (see github.com/jpaulm/gofbp ) from a StreamWork net definition file.","title":"gofbp script"},{"location":"rdm/#gofbp-example-from-swsrcmodeltestsgofbploadbalsw","text":"","title":"gofbp Example (from sw/src/model/tests/gofbp/loadbal.sw)"},{"location":"rdm/#given-loadbalsw","text":"$core = \"github.com/jpaulm/gofbp/core\"; $trtn = \"github.com/jpaulm/gofbp/components/testrtn\"; (Sender $trtn/Sender \"10 COUNT=10\")OUT -load> IN.0(LoadBalance $trtn/LoadBalance ); (LoadBalance)OUT.1 -load> IN(Receiver0 $trtn/DelayedReceiver); (LoadBalance)OUT.2 -load> IN(Receiver1 $trtn/Receiver); (LoadBalance)OUT.3 -load> IN(Receiver2 $trtn/Receiver); gofbp -b loadbal produces and (on console) Input to Receiver: Receiver1 > IP - # 1 Input to Receiver: Receiver1 > IP - # 4 Input to Receiver: Receiver1 > IP - # 6 Input to Receiver: Receiver1 > IP - # 8 Input to Receiver: Receiver2 > IP - # 0 Input to Receiver: Receiver2 > IP - # 3 Input to Receiver: Receiver2 > IP - # 7 Input to DelayedReceiver: Receiver0 > IP - # 2 Input to DelayedReceiver: Receiver0 > IP - # 5 Input to DelayedReceiver: Receiver0 > IP - # 9","title":"Given: LOADBAL.SW"},{"location":"rdm/#generate-a-project","text":"swproject .../nds/postage.sw produces the following source tree: postage \u251c\u2500\u2500 addr \u2502 \u251c\u2500\u2500 GetDest.go \u2502 \u2514\u2500\u2500 GetDest_test.go \u251c\u2500\u2500 ComputePostage.go \u251c\u2500\u2500 ComputePostage_test.go \u251c\u2500\u2500 config.go \u251c\u2500\u2500 getr \u2502 \u251c\u2500\u2500 Rates.go \u2502 \u2514\u2500\u2500 Rates_test.go \u251c\u2500\u2500 go.mod \u251c\u2500\u2500 go.sum \u251c\u2500\u2500 internal \u2502 \u251c\u2500\u2500 gen_swproject \u2502 \u251c\u2500\u2500 postage.go \u2502 \u251c\u2500\u2500 postage.sw \u2502 \u2514\u2500\u2500 sw.cfg \u251c\u2500\u2500 postage.yaml \u251c\u2500\u2500 PrintLabel.go \u2514\u2500\u2500 PrintLabel_test.go then produces this graph vets the code, and finally runs it.","title":"Generate a project"},{"location":"rdm/#swsh-synopsis","text":"sw.sh-1.0.1 USAGE: b|build . Build project with Autotools. c . Make check cl . Show release check list. d [OPTs] . Switch to docker container. e . Exit SW shell. d build [OPTs] . Build SWdemo docker container. doc . Run and browse Doxygen j . Graph collate.sw with swgraph jl . Generate and view locusts.png p [NAME..] . Generate project(s) named NAME... poc . Build and run Proof of Concept rm . View README in /opt/google/chrome/chrome rc . Build and run Collate program rl . Run locusts program s . Enter SW shell. 'e' to exit the shell. v . Display this script version x . Edit this script --help . Display this help","title":"sw.sh Synopsis"},{"location":"rdm/#bugs","text":"sw.Gen fails unless all three arguments are present. Stream directors like => and <= are accepted, but treated the same as -> and <-, except for appearing differently in graphs. The meaning is reserved for future use, which could break existing networks.","title":"BUGS:"},{"location":"rdm/#home-page","text":"(https://sw.twyoung.com)","title":"Home Page"},{"location":"rdm/#release-notes","text":"","title":"Release Notes"},{"location":"rdm/#0180","text":"Reorganized repo tree structure Renamed package swbase to sw and moved code to repo root Changed package swutility to import package sw","title":"0.18.0"},{"location":"rdm/#0184","text":"Fixes for restructure problems Fixes to bash scripts Fixes to githup builds","title":"0.18.4"},{"location":"rdm/#0185","text":"More fixes Moved .../sw/c to .../sw/src","title":"0.18.5"},{"location":"rdm/#0186","text":"Created gofbp script Added sw/testrtn package","title":"0.18.6"},{"location":"rdm/#0187","text":"Moved build process to project tree root","title":"0.18.7"},{"location":"rdm/#0188","text":"Fixed count in swbal.sw","title":"0.18.8"},{"location":"rdm/#0189","text":"Fix testrtn/Sender","title":"0.18.9"},{"location":"rdm/#0190","text":"Many fixes to swproject script","title":"0.19.0"},{"location":"rdm/#0201","text":"Fix swgraph file search","title":"0.20.1"},{"location":"rdm/#0206","text":"Incorporate component attributes in SWL for future graphing enhancements. Fix fan logic when connection is missing.","title":"0.20.6"},{"location":"rdm/#0207","text":"Improve gofbp script Update README","title":"0.20.7"},{"location":"rdm/#0208","text":"Created fileio package with GetFile and PutFile and FileT","title":"0.20.8"},{"location":"rdm/#02010","text":"Provide process attributes.","title":"0.20.10"},{"location":"rdm/#0210","text":"Can generate projects with or without YAML configuration. Fixes to Wrap function.","title":"0.21.0"},{"location":"rdm/#0211","text":"README updates Updated SWL.pdf","title":"0.21.1"},{"location":"rdm/#0220","text":"Go code generation revamped Typed channels partly implemented, possibly breaking networks with types specified in a director.","title":"0.22.0"},{"location":"rdm/#0266","text":"Fixed double arrow graph error","title":"0.26.6"},{"location":"rdm/#0267","text":"Introduced mkdocs Attempt to fix go.in yaml Dependabot alert Fix build error in swgraph.c","title":"0.26.7"},{"location":"rdm/#0268","text":"Removed 'default:' error from swgraph.c","title":"0.26.8"},{"location":"rdm/#0269","text":"Fixed bug with subnet attributes","title":"0.26.9"},{"location":"rdm/#02610","text":"Fixed maximum subnet level checking Introducted mkdocs web site docs","title":"0.26.10"},{"location":"rdm/#02611","text":"Changed type mismatches from FAILing to WARNING.","title":"0.26.11"},{"location":"rdm/#0270","text":"Changed package name from sw/linux to sw/os Added sw/os/Debug function","title":"0.27.0"},{"location":"rdm/#author","text":"Tom Young, streamwork@twyoung.com with thanks to J. Paul Morrison, Phillip W. Young, Sam Watkins, the contributors to flow-based-programming@googlegroups.com, and to the developers/maintainers of Go, gcc, Linux/Ubuntu, BNFC, git, GraphViz, Github and others.","title":"Author"},{"location":"components/config/","text":"package cfg // import \"github.com/tyoung3/sw/config\" FUNCTIONS func pkgConfig() *config.Config PkgConfig initializes the go-config package. See: https://github.com/zpatrick/go-config for details func recv(ci chan interface{}, wg2 sync.WaitGroup, arg []string, nport int) func send(ci chan interface{}, wg2 sync.WaitGroup, arg []string, nport int) TYPES type IpT struct { P string / Process Name / S string / modulepath/component / I int / Port number / } IpT is a common IP default type","title":"Config"},{"location":"components/fileio/","text":"package fileio // import \"github.com/tyoung3/sw/fileio\" FUNCTIONS func Getfile(wg *sync.WaitGroup, arg []string, cs []chan interface{}) Getfile is @todo undocumented func Putfile(wg *sync.WaitGroup, arg []string, cs []chan interface{}) Putfile is @todo undocumented TYPES type FileT struct { S string / Statement / L int / Line Number -1=File name / }","title":"Fileio"},{"location":"components/os/","text":"package os // import \"github.com/tyoung3/sw/os\" Package sw/os provides Operating System specific functionality for StreamWork Golang components. FUNCTIONS func Debug(s string) Debug prints string, s, in yellow, if debugging mode is set ( DEBUG=\"Y\"). func Wrap(wg *sync.WaitGroup, arg []string, cs []chan interface{}) Wrap launches the specified linux executable and separate goroutines to a) forward all text lines from channel 0(cs[0]) to the executable's stdin pipe; b) forward text lines from the stdout pipe to channel 1; and c) forward text lines from stderr to channel 2.","title":"Linux"},{"location":"components/sw/","text":"package sw // import \"github.com/tyoung3/sw\" Package sw contains a number of basic, standard StreamWork components. The program 'sw' can create a main/Go program(cmd) from a Streamwork network definition. The generated cmd launches the component processes specified in the network definition as separate go routines. This package contains basic Streamwork components: Split, Join, Gen, Pass, Print, etc. Other .../sw/ packages are: config, swutility, and linux. Sw components have a simple interface. There is no complex API; there are no StreamWork required import statements. Just the exported function is required. This makes it easy to create your own components. The bash script, swproject generates an entire project tree from a network definition FUNCTIONS func Gen(wg *sync.WaitGroup, arg []string, cs []chan interface{}) Gen sends 'nbr' integers, beginning with 'start', incremented by 'inc'; argcuments 1, 2, and 3 respectively over port 0. #####Examples (Gen will send: 1 2 3 4 5 6 7 (Gen \"-i\" \"9\" \"2\" \"3\") will send: 2 5 8 11 14 17 20 23 26 (Gen \"-i\" \"3\" \"17\") will send: 17 18 19 (Gen \"-i\" \"4\" \"-2\" \"-1\") will send: -2 -3 -4 -5 func Gens(wg *sync.WaitGroup, arg []string, cs []chan interface{}) Gens sends arg[1], arg[2] long strings to channel cs[0] (out1) Strings consist of the process name and seq. no; i.e. G3-1, G3-2, etc. BUG cannot set length, yet. func Join(wg1 *sync.WaitGroup, arg []string, cs []chan interface{}) Join sends all input from channels [1:n] to channel [0], port 0. func Pass(wg *sync.WaitGroup, arg []string, cs []chan interface{}) Pass delays input from chanell 0 for arg[1] milliseconds, then sends it out on channel 1. func Print(wg *sync.WaitGroup, arg []string, cs []chan interface{}) Print prints integers and strings received from port 0, prefixed with the process identifier(arg[0]) string, func Split(wg *sync.WaitGroup, arg []string, cs []chan interface{}) Split copies all input from port 0, to all active ports 1,..N","title":"SwBase"},{"location":"components/swutility/","text":"package swutility // import \"github.com/tyoung3/sw/swutility\" Package swutility provides merge and collate StreamWork components. FUNCTIONS func Collate(wg *sync.WaitGroup, arg []string, cs []chan interface{}) Collate compares IPs from two channels(0,1). Matching IPs are sent to channels 2 and 3, while mismatches from (0,1) are sent to (4,5) respectively. func Merge(wg *sync.WaitGroup, arg []string, cs []chan interface{}) Merge compares input from channels 1 and 2 sending the lowest data to channel 0. func MergeInt(wg *sync.WaitGroup, cs ...chan interface{}) MergeInt sends all input from channels cs[1:n] to channel cs[0] in order of arrival.","title":"Swutility"}]}