Copyright (C) 2019 Thomas W. Young, streamwork@twyoung.com 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file or its derivitaves except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

SW - STREAMWORK/FrontEnd
=======================

Name
----

         StreamWork - a flow based program(FBP) Go language framework.
         

Description
-----------

StreamWork is a proof-of-concept for a Go language flow-based system 
which reads and executes a StreamWork network definition(ND) file.

A network definition consists of a list of Flows.  Each Flow consists 
of a a sink process, a sink port number, "<-", a source portnumber, and   source process.  

Ex.  

    (In strings.Print1)0 <- 0(Out strings.Gen1);

The IPs are designed as nil(empty) interfaces to be filled by the source components. I.e. the 
interface type is determined by the first send to the channel.  Subsequent sends with different 
types may or may not cause a type mis-match depending on the sink program coding. 

This frontend is limited to just enough logic
 to provide a proof-of-concept.


Everything here. including the project name, is subject to change.  
Versions will be backward compatible within the same major version. 
Ex. your code depending on v0.0.1 will still work on v0.8.7, but may fail on v1.0.0.   

Sw currenly generates Go code from the generated network model.  C and other languages could also be generated. 

Comments and critiques are welcome.    Contributors are encouraged.  
Please do not submit code before contacting the project by e-mailing streamwork@twyoung.com or 
posting a request on Github.     

QuickStart (on Linux) 
----------
	* To run the generated Go code, install the tyoung3/StreamWork backend 
	  from github.  (Requires Go installation.).  The backend should run 
	  in any Golang compatible environment.  Sw will run without  
	  installing tyoung3/StreamWork, the generated Go code just won't work.
	* Download the 'sw' executable from github to any convenient location.e
	* Run 'chmod a+x sw' if necessary. 
	* Run 
	
```	
echo "(Sink strings.Print1)0 <- 0(Source strings.Gen1); " | ./sw > /tmp/main.go 
```
	* Run 'go run /tmp/main.go  ...

OUTPUT: 
```	
	StreamWork Proof of Concept Example.
Sink Source-1
Sink Source-2
Sink Source-3
Sink Source-4
Sink Source-5
Sink Source-6
Sink Source-7
```

SW.cf Language Notes
--------------------
Statements in the network definition language, SW.cf, end
with a semi-colon.  Semi-colons are like periods at the end of
English statements -- they tell the reader (and the interpreter) when
you have reached the end; making reading the statements easier. 
Imagine trying to read a book without any periods (or initial capitals). 
Without semi-colons, line breaks become
necessary  and awkward syntax rules evolve.
The Go language syntax actually requires semi-colons to be supplied by
a smart lexer.  

In the future, there may be some exceptions to the 
semi-colon rule for  special pre-interpreter commands, like INCLUDE.

The, ```<-```,  token is used to be consistent with its 
usage in the Go language.   

Currently only numeric ports are supported.  Named ports are planned.

Comments in the SW.cf file provide 
clues to possible future language additions.  
We will strive hard for backward compatibility.

Collate/Merge Example
---------------------

Given the input file: /tmp/collate.sw  

```   
#/TMP/COLLATE.SW
(C std.Collate  )0       <- 0(G0  std.Gen1 "12" "1" "2" );
(C)1                     <- 0(M);         
(M std.Merge)1           <- 0(G1  std.Gen1 "5"  "5" "1" );
(M)2                     <- 0(G2  std.Gen1 "8"  "2" "3" );
(Match0 strings.Print1)0 <- 2(C std.Collate  );
(Match1 strings.Print1)0 <- 3(C);
(Miss0  strings.Print1)0 <- 4(C);
(Miss1  strings.Print1)0 <- 5(C);
```
running the following (in Linux):
```
	sw < /tmp/collate.sw      > /tmp/collate/main.go
	cd /tmp/collate; go mod init
	go run *go 
```	
will produce:
```
go: finding github.com/tyoung3/streamwork/std latest
go: finding github.com/tyoung3/streamwork/strings latest
StreamWork Proof of Concept Example.
M std.Merge: starting 
G2  std.Gen1 8 2 3
M std.Merge:  2 3
G1  std.Gen1 5 5 1
M std.Merge:  5 3
G0  std.Gen1 12 1 2
M std.Merge:  6 3
    ... 
M std.Merge: exit 
M std.Merge: ending
Miss0 Int: 19
Miss0 Int: 21
Match0 Int: 23
Match1 Int: 17
Match1 Int: 23
```
but not necessarily in that order.

/tmp/sw/main.go:

```
package main

/* DO NOT EDIT!!!
*
    generated by sw/swgo.c-0.3.0/

import "fmt"
import "sync"
import "github.com/tyoung3/streamwork"
import "github.com/tyoung3/streamwork/strings"
import "github.com/tyoung3/streamwork/std"


func main() {
var cs []chan interface{}
var wg sync.WaitGroup

	fmt.Println("StreamWork Proof of Concept Example.")

	for i:=0; i<8; i++ {
		cs = append(cs, make(chan interface{}))
	}

/*       Network Definition  */
/* (Miss1 strings.Print1 )0  <- 5(C std.Collate)	*/
/* (Miss0 strings.Print1 )0  <- 4(C std.Collate)	*/
/* (Match1 strings.Print1 )0  <- 3(C std.Collate)	*/
/* (Match0 strings.Print1 )0  <- 2(C std.Collate)	*/
/* (M std.Merge )2  <- 0(G2 std.Gen1 "8" "2" "3")	*/
/* (M std.Merge )1  <- 0(G1 std.Gen1 "5" "5" "1")	*/
/* (C std.Collate )1  <- 0(M std.Merge)	*/
/* (C std.Collate )0  <- 0(G0 std.Gen1 "12" "1" "2")	*/

fbp.Launch(&wg,[]string{"Miss1"},	  strings.Print1, cs[7:8])
fbp.Launch(&wg,[]string{"Miss0"},	  strings.Print1, cs[6:7])
fbp.Launch(&wg,[]string{"Match1"},	  strings.Print1, cs[5:6])
fbp.Launch(&wg,[]string{"Match0"},	  strings.Print1, cs[4:5])
fbp.Launch(&wg,[]string{"G2","8","2","3"},	      std.Gen1, cs[3:4])
fbp.Launch(&wg,[]string{"G1","5","5"},	      std.Gen1, cs[2:3])
fbp.Launch(&wg,[]string{"M"},	      std.Merge, cs[1:4])
fbp.Launch(&wg,[]string{"G0","12","1","2"},	      std.Gen1, cs[0:1])

	for i:=0; i<6; i++ {
		cs_C:=append(cs_C, make(chan interface{}))
	}
	cs_C[0] = cs[0]
	cs_C[1] = cs[1]
	cs_C[2] = cs[4]
	cs_C[3] = cs[5]
	cs_C[4] = cs[6]
	cs_C[5] = cs[7]
fbp.Launch(&wg,[]string{"C"},	      std.Collate, cs_C[0:6])

wg.Wait()
}

```

Running:
```	 
	sw -m 4 < /tmp/collate.sw > /tmp/collate.dot
	dot -Tjpg  /tmp/collate.dot > /tmp/collate.jpg
```
should produce /tmp/collate.jpg  [copy may be in this directory]

WARNING:
--------
	 std.Gen1  is not the same as strings.Gen1 
  
BUGS:
-----
	 std.Gen1 fails unless all three arguments are present.

Author
------

    Tom Young, streamwork@twyoung.com
    
    with thanks to J.P.Morrison, Sam Watkins, Phillip W. Young, 
    all the other contributors 
    to  flow-based-programming@googlegroups.com, 
    and the developers of Linux, gcc, BNFC, Go, and Github. 
