package main

import (
	"log"
	"os"
	"strings"
	"text/template"
)

func main() {
	// First we create a FuncMap with which to register the function.
	funcMap := template.FuncMap{
		// The name "title" is what the function will be called in the template text.
		"title": strings.Title,
	}

	// A simple template definition to test our function.
	// We print the input text several ways:
	// - the original
	// - title-cased
	// - title-cased and then printed with %q
	// - printed with %q and then title-cased.
	const templateText = `
package main
	
/*StreamWork Go code.
Generated by sw/swgo.c-0.11.9 Thu Mar 18 11:27:15 2021
Configuration file: ./sw.cfg
*/

/***********   Expanded collate.sw Network Definition   **********
(Miss1 poc.Print1 )             <- 5(C poc.Collate);
(Miss0 poc.Print1 )             <- 4(C poc.Collate);
(Match1 poc.Print1 )            <- 3(C poc.Collate);
(Match0 poc.Print1 )            <- 2(C poc.Collate);
(M poc.Merge )1                 <- 0(G2 poc.Gen1 "8" "2" "3");
(M poc.Merge )2                 <- 0(G1 poc.Gen1 "5" "5" "1");
(C poc.Collate )                <- 0(G0 poc.Gen1 "12" "1" "2");
(C poc.Collate )1               <- 0(M poc.Merge);
# 8 streams, 9 processes, 4 components, 1 partition, 0 cycles.
*********************************************/

import "sync"
import "github.com/tyoung3/streamwork/fbp"
import "github.com/tyoung3/streamwork/poc"

func main() {
        var cs []chan interface{}
        var wg sync.WaitGroup

        cs = append(cs, make(chan interface{}))
        cs = append(cs, make(chan interface{}))
        cs = append(cs, make(chan interface{}))
        cs = append(cs, make(chan interface{}))      
        cs = append(cs, make(chan interface{}))
        cs = append(cs, make(chan interface{}))
        cs = append(cs, make(chan interface{}))
        cs = append(cs, make(chan interface{}))

        fbp.Launch(&wg, []string{"Miss1"}, poc.Print1, cs[7:8])
        fbp.Launch(&wg, []string{"Miss0"}, poc.Print1, cs[6:7])
        fbp.Launch(&wg, []string{"Match1"}, poc.Print1, cs[5:6])
        fbp.Launch(&wg, []string{"Match0"}, poc.Print1, cs[4:5])
        fbp.Launch(&wg, []string{"G2", "8", "2", "3"}, poc.Gen1, cs[3:4])
        fbp.Launch(&wg, []string{"G1", "5", "5", "1"}, poc.Gen1, cs[2:3])
        fbp.Launch(&wg, []string{"G0", "12", "1", "2"}, poc.Gen1, cs[1:2])

        var cs_C []chan interface{}
        for i := 0; i < 6; i++ {
                cs_C = append(cs_C, make(chan interface{}, 2))
        }
        cs_C[0] = cs[1]
        cs_C[1] = cs[0]
        cs_C[2] = cs[4]
        cs_C[3] = cs[5]
        cs_C[4] = cs[6]
        cs_C[5] = cs[7]
        fbp.Launch(&wg, []string{"C"}, poc.Collate, cs_C[0:6])
        var cs_M []chan interface{}
        for i := 0; i < 3; i++ {
                cs_M = append(cs_M, make(chan interface{}, 2))
        }
        cs_M[0] = cs[0]
        cs_M[1] = cs[3]
        cs_M[2] = cs[2]
        fbp.Launch(&wg, []string{"M"}, poc.Merge, cs_M[0:3])

        wg.Wait()
}

`

	// Create a template, add the function map, and parse the text.
	tmpl, err := template.New("titleTest").Funcs(funcMap).Parse(templateText)
	if err != nil {
		log.Fatalf("parsing: %s", err)
	}

	// Run the template to verify the output.
	err = tmpl.Execute(os.Stdout, "the go programming language")
	if err != nil {
		log.Fatalf("execution: %s", err)
	}

}
